# Copyright (c) 06.10.2023 Thomas Zierer
#
# This program and the accompanying materials are made
# available under the terms of the Eclipse Public License 2.0
# which is available at https://www.eclipse.org/legal/epl-2.0/
#
# SPDX-License-Identifier: EPL-2.0

ABS = ABS returns the absolute value of x. It is the positive value of x.$ABS(x)$x Expression.\r\nThe mode of the result is REAL. The result has the base, scale, and precision of x,\r\nexcept when x is COMPLEX FIXED(p,q). In the latter case, the result is REAL\r\nFIXED(min(n,p+1),q) where n is N for DECIMAL and M for BINARY.
ACOS = ACOS returns a real floating-point value that is an approximation of the inverse\r\n(arc) cosine in radians of x.$ACOS(x)$x Real expression, where ABS(x) <= 1.\r\nThe result is in the range:\r\n0 ? ACOS(x) ? ?\r\nand has the base and precision of x.
ADD = ADD returns the sum of x and y with a precision specified by p and q. The base,\r\nscale, and mode of the result are determined by the rules for expression evaluation\r\nunless overruled by the PRECTYPE compiler option.$ADD(x,y,p ),q$x and y\r\nExpressions.\r\np Restricted expression. It specifies the number of digits to be maintained\r\nthroughout the operation.\r\nq Restricted expression specifying the scaling factor of the result. For a\r\nfixed-point result, if q is omitted, a scaling factor of zero is the default. For a\r\nfloating-point result, q must be omitted.\r\nADD can be used for subtraction by prefixing a minus sign to the operand to be\r\nsubtracted.
ADDR = ADDR returns the pointer value that identifies the generation of x.$ADDR(x)$x Reference. It refers to a variable of any data type, data organization, alignment,\r\nand storage class except:\r\nv A subscripted reference to a variable that is an unaligned fixed-length bit\r\nstring\r\nv A reference to a DEFINED or BASED variable or simple parameter, which is\r\nan unaligned fixed-length bit string\r\nv A minor structure or union whose first base element is an unaligned\r\nfixed-length bit string (except where it is also the first element of the\r\ncontaining major structure or union)\r\nv A major structure or union that has the DEFINED attribute or is a\r\nparameter, and that has an unaligned fixed-length bit string as its first\r\nelement\r\nv A reference that is not to connected storage\r\nIf x is a reference to:\r\nv An aggregate parameter, it must have the CONNECTED attribute\r\nv An aggregate, the returned value identifies the first element\r\nv A component or cross section of an aggregate, the returned value takes into\r\naccount subscripting and structure or union qualification\r\nv A varying string, the returned value identifies the 2-byte prefix\r\nv An area, the returned value identifies the control information\r\nv A controlled variable that is not allocated in the current program, the null\r\npointer value is returned\r\nv A based variable, the result is the value of the pointer explicitly qualifying x\r\n(if it appears), or associated with x in its declaration (if it exists), or a null\r\npointer\r\nv A parameter, and a dummy argument has been created, the returned value\r\nidentifies the dummy argument
ADDRDATA = ADDRDATA returns the pointer value that identifies the generation of x.$ADDRDATA(x)$x Reference.\r\nADDRDATA behaves the same as the ADDR built-in function except in the\r\nfollowing instance:\r\nv When applied to a varying string, ADDRDATA returns the address of the first\r\ndata byte of the string (rather than of the length field).
ALL = ALL returns a bit string in which each bit is 1 if the corresponding bit in each\r\nelement of x exists and is 1. The length of the result is equal to that of the longest\r\nelement.$ALL(x)$x Computational array expression. If x is not a bit string array, then x is\r\nconverted to a bit string array.
ALLOCATE = ALLOCATE allocates storage of size n in heap storage and returns the pointer to\r\nthe allocated storage.$ALLOCATE(n)$Abbreviation: ALLOC\r\nn Expression. n must be nonnegative. If necessary, n is converted to REAL FIXED\r\nBINARY(31,0).\r\nIf the requested amount of storage is not available, the STORAGE condition is\r\nraised.
ALLOCATION = ALLOCATION returns a FIXED BINARY(31,0) specifying the number of\r\ngenerations that can be accessed in the current program for x.$ALLOCATION(x)$Abbreviation: ALLOCN\r\nx Level-1 unsubscripted controlled variable.\r\nIf x is not allocated in the current program, the result is zero.
ALLOCSIZE = ALLOCSIZE returns a FIXED BIN(31,0) value giving the amount of storage\r\nallocated with a specified pointer. To use this built-in function, you must also\r\nspecify the CHECK(STORAGE) compile-time option.$ALLOCSIZE(p)$p Pointer expression.\r\nALLOCSIZE returns 0 if the pointer does not point to the start of a piece of\r\nallocated storage.\r\nNote that the pointer passed to ALLOCSIZE is "rounded down" to the nearest\r\ndoubleword and that rounded value is compared against all allocated addresses\r\nwhen similarly rounded down.
ANY = ANY returns a bit string in which each bit is 1 if the corresponding bit in any\r\nelement of x exists and is 1. The length of the result is equal to that of the longest\r\nelement.$ANY(x)$x Computational array expression. If x is not a bit string array, then x is\r\nconverted to a bit string array.
ASIN = ASIN returns a real floating-point value that is an approximation of the inverse\r\n(arc) sine in radians of x.$ASIN(x)$x Real expression, where ABS(x) <= 1.\r\nThe result is in the range:\r\n-?/2 ? ASIN(x) ? ?/2\r\nand has the base and precision of x.
ATAN = ATAN returns a floating-point value that is an approximation of the inverse (arc)\r\ntangent in radians of x or of a ratio x/y.$ATAN(x ),y$x and y\r\nExpressions.\r\nIf x alone is specified, the result has the base and precision of x, and is in the\r\nrange:\r\n-?/2 < ATAN(x) < ?/2\r\nIf x and y are specified, each must be real. An error exists if x and y are both\r\nzero. The result for all other values of x and y has the precision of the longer\r\nargument, a base determined by the rules for expressions, and a value given\r\nby:\r\nATAN(x/y) for y>0\r\n?/2 for y=0 and x>0\r\n-?/2 for y=0 and x<0\r\n? + ATAN(x/y) for y<0 and x>=0\r\n-? + ATAN(x/y) for y<0 and x<0
ATAND = ATAND returns a real floating-point value that is an approximation of the inverse\r\n(arc) tangent in degrees of x or of a ratio x/y.$ATAND(x ),y$x and y\r\nExpressions.\r\nIf x alone is specified it must be real. The result has the base and precision of\r\nx, and is in the range:\r\n-90 < ATAND(x) < 90\r\nIf x and y are specified, each must be real. The value of the result is given by:\r\n(180/?) * ATAN(x,y)\r\nFor argument requirements and attributes of the result see ?ATAN? on page 417.
ATANH = ATANH returns a floating-point value that has the base, mode, and precision of x,\r\nand is an approximation of the inverse (arc) hyperbolic tangent of x.$ATANH(x)$x Expression. ABS(x)<1.\r\nThe result has a value given by:\r\nLOG((1 + x)/(1 - x))/2
AUTOMATIC = AUTOMATIC allocates storage of size n automatic storage and returns the pointer\r\nto the allocated storage.$AUTOMATIC(n)$Abbreviation: AUTO\r\nn Expression. n must be nonnegative. If necessary, n is converted to REAL FIXED\r\nBINARY(31,0).\r\nThe storage acquired cannot be explicitly freed; the storage is automatically freed\r\nwhen the block terminates.
AVAILABLEAREA = AVAILABLEAREA returns a FIXED BINARY(31,0) value. The value returned by\r\nAVAILABLEAREA is the size of the largest single allocation that can be obtained\r\nfrom the area x.$AVAILABLEAREA(x)$x A reference with the AREA attribute.\r\nExample\r\ndcl Uarea area(1000);\r\ndcl Pz ptr;\r\ndcl C99z char(99) varyingz based(Pz);\r\ndcl (SizeBefore, SizeAfter) fixed bin(31);\r\nSizeBefore = availablearea(Uarea); /* returns 1000 */\r\nAlloc C99z in(Uarea);\r\nSizeAfter = availablearea(Uarea); /* returns 896 */\r\ndcl C9 char(896) based(Pz);\r\nAlloc C9 in(Uarea);
BINARY = BINARY returns the binary value of x, with a precision specified by p and q. The\r\nresult has the mode and scale of x.$BINARY(x ),p,q$Abbreviation: BIN\r\nx Expression.\r\np Restricted expression. Specifies the number of digits to be maintained\r\nthroughout the operation; it must not exceed the implementation limit.\r\nq Restricted expression. It specifies the scaling factor of the result. For a\r\nfixed-point result, if p is given and q is omitted, a scaling factor of zero is the\r\ndefault. For a floating-point result, q must be omitted.\r\nIf both p and q are omitted, the precision of the result is determined from the rules\r\nfor base conversion.
BINARYVALUE = BINARYVALUE returns a FIXED BINARY(31,0) value that is the converted value\r\nof x; x can be a pointer, offset, or ordinal.$BINARYVALUE(x)$Abbreviation: BINVALUE\r\nx Expression.
BIT = BIT returns a result that is the bit value of x, and has a length specified by y.$BIT(x ),y$x Expression.\r\ny Expression. If necessary, y is converted to a real fixed-point binary value. If y is\r\nomitted, the length is determined by the rules for type conversion. If y = 0, the\r\nresult is the null bit string. y must not be negative.
BITLOCATION = BITLOCATION returns a FIXED BINARY(31,0) result that is the location of bit x\r\nwithin the byte that contains x. The value returned is always between 0 and 7 (0 ?\r\nvalue ? 7).$BITLOCATION(x)$Abbreviation: BITLOC\r\nx Reference of type unaligned bit. If x does not have type unaligned bit, a value\r\nof 0 is returned.\r\nx must not be subscripted.\r\nBITLOCATION can be used in restricted expressions, with the following\r\nlimitations. If BITLOC(x) is used to set:\r\nv The extent of a variable y that must have constant extents, or\r\nv The value of a variable y that must have a constant value,\r\nthen x must be declared before y.\r\nFor examples, see ?LOCATION? on page 521.
BOOL = BOOL returns a bit string that is the result of the Boolean operation z, on x and y.\r\nThe length of the result is equal to that of the longer operand, x or y.$BOOL(x,y,z)$x and y\r\nExpressions. x and y are converted to bit strings, if necessary. If x and y are of\r\ndifferent lengths, the shorter is padded on the right with zeros to match the\r\nlonger.\r\nz Expression. z is converted to a bit string of length 4, if necessary. When a bit\r\nfrom x is matched with a bit from y, the corresponding bit of the result is\r\nspecified by a selected bit of z, as follows:\r\nx y Result\r\n0 0 bit 1 of z\r\n0 1 bit 2 of z\r\n1 0 bit 3 of z\r\n1 1 bit 4 of z
BYTE = BYTE is a synonym for CHARVAL. For more information, refer to ?CHARVAL? on\r\npage 436.$null$null
CDS = CDS returns a FIXED BINARY(31) value that indicates if the old and current\r\nvalues in a compare double and swap were equal.$CDS(p,q,x)$p Address of the old FIXED BINARY(63) value.\r\nq Address of the current FIXED BINARY(63) value.\r\nx The new FIXED BINARY(63) value.\r\nCDS compares the "current" and "old" values. If they are equal, the "new" value is\r\ncopied over the "current", and a value of 0 is returned. If they are unequal, the\r\n"current" value is copied over the "old", and a value of 1 is returned.\r\nOn z/OS, the CDS built-in function implements the CDS instruction. For a detailed\r\ndescription of this function, read the appendices in the Principles of Operations\r\nmanual.\r\nOn Intel, the CDS built-in function uses the Intel cmpxchg8 instruction in the same\r\nmanner that the CS built-in function uses the cmpxchg4 instruction.
CEIL = CEIL determines the smallest integer value greater than or equal to x, and assigns\r\nthis value to the result.$CEIL(x)$x Real expression.\r\nThe result has the mode, base, scale, and precision of x, except when x is\r\nfixed-point with precision (p,q). The precision of the result is then given by:\r\n(min(N,max(p-q+1,1)),0)\r\nwhere N is the maximum number of digits allowed.
CENTERLEFT = CENTERLEFT returns a string that is the result of inserting string x in the center\r\n(or one position to the left of center) of a string with length y and padded on the\r\nleft and on the right with the character z as needed. Specifying a value for z is\r\noptional.$CENTERLEFTCENTRELEFT(x,y ),z$null
CENTRELEFT = (x,y )\r\n,z$$Abbreviation: CENTER\r\nx Expression that is converted to character.\r\ny Expression that is converted to FIXED BINARY(31,0).\r\nz Optional expression. If specified, z must be CHARACTER(1) NONVARYING\r\ntype.\r\nExample\r\ndcl Source char value('Feel the Power');\r\ndcl Target20 char(20);\r\ndcl Target21 char(21);\r\nTarget20 = center (Source, length(Target20), '*');\r\n/* '***Feel the Power***' - exactly centered */\r\nTarget21 = center (Source, length(Target21), '*');\r\n/* '***Feel the Power****' - leaning left! */\r\nIf z is omitted, a blank is used as the padding character.\r\nCENTERLEFT\r\nAbbreviation: CENTRE\r\nCENTRELEFT is a synonym for CENTERLEFT.
CENTERRIGHT = CENTERRIGHT returns a string that is the result of inserting string x in the center\r\n(or one position to the right of center) of a string with length y and padded on the\r\nleft and on the right with the character z as needed. Specifying a value for z is\r\noptional.$CENTERRIGHTCENTRERIGHT(x,y ),z$null
CENTRERIGHT = (x,y )\r\n,z$$x Expression that is converted to character.\r\ny Expression that is converted to FIXED BINARY(31,0).\r\nz Optional expression. If specified, z must be CHARACTER(1) NONVARYING\r\ntype.\r\nExample\r\ndcl Source char value('Feel the Power');\r\ndcl Target20 char(20);\r\ndcl Target21 char(21);\r\nTarget20 = centerright (Source, length(Target20), '*');\r\n/* '***Feel the Power***' - exactly centered */\r\nTarget21 = centerright (Source, length(Target21), '*');\r\n/* '****Feel the Power***' - leaning right! */\r\nIf z is omitted, a blank is used as the padding character.\r\nCENTERRIGHT\r\nCENTRERIGHT is a synonym for CENTERRIGHT.
CHARACTER = CHARACTER returns the character value of x, with a length specified by y.\r\nCHARACTER also supports conversion from graphic to character type.$CHARACTER(x ),y$Abbreviation: CHAR\r\nx Expression.\r\nx must have a computational type.\r\nWhen x is nongraphic, CHARACTER returns x converted to character.\r\nWhen x is GRAPHIC, CHARACTER returns x converted to SBCS characters. If\r\na DBCS character cannot be translated to an SBCS equivalent, the\r\nCONVERSION condition is raised.\r\nThe values of x are not checked.\r\ny Expression. If necessary, y is converted to a real fixed-point binary value.\r\nIf y is omitted, the length is determined by the rules for type conversion.\r\ny cannot be negative.\r\nIf y = 0, the result is the null character string.\r\nExample\r\nConversion from graphic to character:\r\ndcl X graphic(6);\r\ndcl A char (6);\r\nA = char(X);\r\nFor X with value Intermediate Result A is assigned\r\n.A.B.C.D.E.F ABCDEF ABCDEF
CHARGRAPHIC = CHARGRAPHIC converts a GRAPHIC (DBCS) string x to a mixed character string\r\nwith a length specified by y.$CHARGRAPHIC(x ),y$Abbreviation: CHARG\r\nx Expression.\r\nx must be a GRAPHIC string. CHARACTER returns x converted to a mixed\r\ncharacter string.\r\ny Expression. If necessary, y is converted to a real fixed-point binary value.\r\nIf y is omitted, the length is determined by the rules for type conversion.\r\ny cannot be negative.\r\nIf y = 0, the result is the null character string.\r\nThe following rules apply:\r\nv If y = 1, the result is a character string of 1 blank.\r\nv If y is greater than the length needed to contain the character string, the\r\nresult is padded with SBCS blanks.\r\nv If y is less than the length needed to contain the character string, the result\r\nis truncated. The integrity is preserved by truncating after a graphic, and\r\nappending an SBCS blank if necessary, to complete the length of the string.\r\nExample 1\r\nConversion from graphic to character, where y is long enough to contain the result:\r\ndcl X graphic(6);\r\ndcl A char (12);\r\nA = char(X,12);\r\nFor X with value Intermediate Result A is assigned\r\n.A.B.C.D.E.F .A.B.C.D.E.F .A.B.C.D.E.F\r\nExample 2\r\nConversion from graphic to character, where y is too short to contain the result:\r\ndcl X graphic(6);\r\ndcl A char (12);\r\nA = char(X,11);\r\nFor X with value Intermediate Result A is assigned\r\n.A.B.C.D.E.F .A.B.C.D.E.F .A.B.C.D.Eb
CHARVAL = CHARVAL returns the CHARACTER(1) value corresponding to an integer.$CHARVAL ( n )$n Expression converted to UNSIGNED FIXED BIN(8) if necessary.\r\nCHARVAL(n) has the same bit value as n (that is, UNSPEC(CHARVAL(n)) is equal\r\nto UNSPEC(n)), but it has the attributes CHARACTER(1).\r\nCHARVAL is the inverse of RANK (when applied to character).
CHECKSTG = CHECKSTG returns a bit(1) value which indicates whether a specified pointer\r\nvalue is the start of a piece of uncorrupted allocated storage. If no pointer value is\r\nsupplied, CHECKSTG determines whether all allocated storage is uncorrupted. To\r\nuse this built-in function, you must also specify the CHECK(STORAGE)\r\ncompile-time option.$CHECKSTG( )p$p Pointer expression.\r\nWhen an allocation is made, it is followed by eight extra bytes which are set to\r\n'ff'x. The allocation is considered uncorrupted if those bytes have not been altered.\r\nThe pointer expression must point to storage allocated for a BASED variable.
COLLATE = COLLATE returns a CHARACTER(256) string comprising the 256 possible\r\nCHARACTER(1) values one time each in the collating order.$COLLATE()$null
COMPARE = COMPARE returns a FIXED BINARY(31,0) value that is:\r\nv Zero, if the z bytes at the addresses x and y are identical\r\nv Negative, if the z bytes at x are less than those at y\r\nv Positive, if the z bytes at x are greater than those at y$COMPARE(x,y,z)$x and y\r\nExpressions. Both must have the POINTER or OFFSET type. If OFFSET, the\r\nexpression must be declared with the AREA qualification.\r\nz Expression that is converted to FIXED BINARY(31,0).\r\nExample\r\ndcl Result fixed bin;\r\ndcl 1 Str1,\r\n2 B fixed bin(31),\r\n2 C pointer,\r\n2 * union,\r\n3 D char(4),\r\n3 E fixed bin(31),\r\n3 *,\r\n4 * char(3),\r\n4 F fixed bin(8) unsigned,\r\n2 * char(0);\r\ndcl 1 Template nonasgn static,\r\n2 * fixed bin(31) init(16), /* ''X */\r\n2 * pointer init(null()),\r\n2 * char(4) init(''),\r\n2 * char(0);\r\ncall plimove(addr(Str1), addr(Template), stg(Str1));\r\nResult = compare(addr(Str1), addr(Template), stg(Str1)); /* 0 */\r\nD = 'DSA ';\r\nResult = compare(addr(Str1), addr(Template), stg(Str1)); /* 1 */\r\nB = 15; /* '00000F00'X */\r\nD = 'DSA ';\r\nResult = compare(addr(Str1), addr(Template), stg(Str1)); /* ?1 */
COMPLEX = COMPLEX returns the complex value x + yI.$COMPLEX(x,y)$Abbreviation: CPLX\r\nx and y\r\nReal expressions.\r\nIf x and y differ in base, the decimal argument is converted to binary. If they\r\ndiffer in scale, the fixed-point argument is converted to floating-point. The\r\nresult has the common base and scale.\r\nIf fixed-point, the precision of the result is given by the following:\r\n(min(N,max(p1-q1,p2-q2)+max(q1,q2)),max(q1,q2))\r\nIn this example, (p1,q1) and (p2,q2) are the precisions of x and y, respectively, and\r\nN is the maximum number of digits allowed.\r\nAfter any necessary conversions have been performed, if the arguments are\r\nfloating-point, the result has the precision of the longer argument.
CONJG = CONJG returns the conjugate of x, that is, the value of the expression with the sign\r\nof the imaginary part reversed.$CONJG(x)$x Expression.\r\nIf x is real, it is converted to complex. The result has the base, scale, mode, and\r\nprecision of x.
COPY = COPY returns a string consisting of y concatenated copies of the string x.$COPY(x,y)$x Expression.\r\nx must have a computational type and should have a string type. If not, it is\r\nconverted to character.\r\ny An integer expression with a nonnegative value. It specifies the number of\r\nrepetitions. It must have a computational type and is converted to FIXED\r\nBINARY(31,0).\r\nIf y is zero, the result is a null string.\r\nConsidering the following code:\r\ncopy('Walla ',1) /* returns 'Walla ' */\r\nrepeat('Walla ',1) /* returns 'Walla Walla ' */\r\nIn the preceding example, repeat(x,n) is equivalent to copy(x,n+1).
COS = COS returns a floating-point value that has the base, precision, and mode of x, and\r\nis an approximation of the cosine of x.$COS(x)$x Expression with a value in radians.
COSD = COSD returns a real floating-point value that has the base and precision of x, and\r\nis an approximation of the cosine of x.$COSD(x)$x Real expression with a value in degrees.
COSH = COSH returns a floating-point value that has the base, precision, and mode of x,\r\nand is an approximation of the hyperbolic cosine of x.$COSH(x)$x Expression.
COUNT = COUNT returns an unscaled REAL FIXED BINARY value specifying the number of\r\ndata items transmitted during the last GET or PUT operation on x.$COUNT(x)$x File-reference. The file must be open and have the STREAM attribute.\r\nThe count of transmitted items for a GET or PUT operation on x is initialized to\r\nzero before the first data item is transmitted, and is incremented by one after the\r\ntransmission of each data item in the list. If x is not open in the current program, a\r\nvalue of zero is returned.\r\nIf an ON-unit or procedure is entered during a GET or PUT operation, and within\r\nthat ON-unit or procedure, a GET or PUT operation is executed for x, the value of\r\nCOUNT is reset for the new operation. It is restored when the original GET or\r\nPUT is continued.\r\nThe BIFPREC compiler option determines the precision of the result returned.
CS = CS returns a FIXED BINARY(31) value that indicates if the old and current values\r\nin a compare and swap were equal.$CS(p,q,x)$p Address of the old FIXED BINARY(31) value.\r\nq Address of the current FIXED BINARY(31) value.\r\nx The new FIXED BINARY(31) value.\r\nCS compares the "current" and "old" values. If they are equal, the "new" value is\r\ncopied over the "current", and a value of 0 is returned. If they are unequal, the\r\n"current" value is copied over the "old", and a value of 1 is returned.\r\nSo, CS could be implemented as the following PL/I function, but then it would not\r\nbe atomic at all. :\r\ncs: proc( old_Addr, current_Addr, new )\r\nreturns( fixed bin(31) byvalue )\r\noptions( byvalue );\r\ndcl old_Addr pointer;\r\ndcl current_Addr pointer;\r\ndcl new fixed bin(31);\r\ndcl old fixed bin(31) based(old_addr);\r\ndcl current fixed bin(31) based(current_addr);\r\nif current = old then\r\ndo;\r\ncurrent = new;\r\nreturn( 0 );\r\nend;\r\nelse\r\ndo;\r\nold = current;\r\nreturn( 1 );\r\nend;\r\nend;\r\nOn z/OS, the CS built-in function implements the CS instruction. For a detailed\r\ndescription of this function, read the appendices in the Principles of Operations\r\nmanual.\r\nOn Intel, the CDS built-in function uses the Intel cmpxchg4 instruction. The\r\ncmpxchg4 instruction takes the address of a "current" value, a "new" value and an\r\n"old" value. It returns the original "current" value and updates it with the "new"\r\nvalue only if it equaled the "old" value.\r\nSo, on Intel, the CS built-in function is implemented via the following inline\r\nfunction:\r\ncs: proc( old_Addr, current_Addr, new )\r\nreturns( fixed bin(31) byvalue )\r\noptions( byvalue );\r\ndcl old_Addr pointer;\r\ndcl current_Addr pointer;\r\ndcl new fixed bin(31);\r\ndcl old fixed bin(31) based(old_addr);\r\ndcl current fixed bin(31) based(current_addr);\r\nif cmpxchg4( current_Addr, new, old ) = old then\r\ndo;\r\nreturn( 0 );\r\nend;\r\nelse\r\ndo;\r\nold = current;\r\nreturn( 1 );\r\nend;\r\nend;
CURRENTSIZE = CURRENTSIZE returns a FIXED BINARY value giving the implementation-defined\r\nstorage, in bytes, required by x.$CURRENTSIZE(x)$x A variable of any data type, data organization, and storage class except:\r\nv A BASED, DEFINED, parameter, subscripted, or structure or union\r\nbase-element variable that is an unaligned fixed-length bit string\r\nv A minor structure or union whose first or last base element is an unaligned\r\nfixed-length bit string (except where it is also the first or last element of the\r\ncontaining major structure or union)\r\nv A major structure or union that has the BASED, DEFINED, or parameter\r\nattribute, and which has an unaligned fixed-length bit string as its first or\r\nlast element\r\nv A variable not in connected storage\r\nThe value returned by CURRENTSIZE(x) is defined as the number of bytes that\r\nwould be transmitted in the following circumstances:\r\ndeclare F file record output\r\nenvironment(scalarvarying);\r\nwrite file(F) from(S);\r\nIf x is a scalar varying-length string, the returned value includes the length-prefix\r\nof the string and the number of currently-used bytes. It does not include any\r\nunused bytes in the string.\r\nIf x is a scalar area, the returned value includes the area control bytes and the\r\ncurrent extent of the area. It does not include any unused bytes at the end of the\r\narea.\r\nIf x is an aggregate containing areas or varying-length strings, the returned value\r\nincludes the area control bytes, the maximum sizes of the areas, the length prefixes\r\nof the strings, and the number of bytes in the maximum lengths of the strings. The\r\nexception to this rule is:\r\nIf x is a structure or union whose last element is a nondimensioned area, the\r\nreturned value includes that area's control bytes and the current extent of that\r\narea. It does not include any unused bytes at the end of that area.\r\nThe CURRENTSIZE built-in function must not be used on a BASED variable with\r\nadjustable extents if that variable has not been allocated.\r\nUnder the CMPAT(V3) compiler option, CURRENTSIZE returns a FIXED BIN(63)\r\nvalue. Under all other CMPAT options, it returns a FIXED BIN(31) value.\r\nFor examples of the CURRENTSIZE built-in function, refer to the ?SIZE? on page\r\n651.
CURRENTSTORAGE = Abbreviation: CSTG\r\nCURRENTSTORAGE is a synonym for CURRENTSIZE. For more information,\r\nrefer to ?CURRENTSIZE? on page 449.$null$null
DATAFIELD = DATAFIELD is in context in a NAME condition ON-unit (or any of its dynamic\r\ndescendants). It returns a character string whose value is the contents of the field\r\nthat raised the condition. It is also in context in an ON-unit (or any of its dynamic\r\ndescendants) for an ERROR or FINISH condition raised as part of the implicit\r\naction for the NAME condition.$DATAFIELD()$If the string that raised the condition contains DBCS identifiers, GRAPHIC data, or\r\nmixed character data, DATAFIELD returns a mixed character string.\r\nIf DATAFIELD is used out of context, a null string is returned.
DATE = DATE returns a nonvarying character(6) string containing the date in the format,\r\nYYMMDD.$DATE()$null
DATETIME = DATETIME returns a character string timestamp of today's date in either the\r\ndefault or a user-specified format.$DATETIME( )y$y Expression\r\nIf present, it specifies the date/time pattern in which the date is returned. If y\r\nis missing, it is assumed to be the default date/time pattern\r\n'YYYYMMDDHHMISS999'.\r\nRefer to Table 51 on page 396 for the allowed patterns.\r\ny must have computational type and should have character type. If not, it is\r\nconverted to character.\r\nSee ?DAYS? on page 454 for an example of using DATETIME.
DAYS = DAYS returns a FIXED BINARY(31,0) value which is the number of days (in Lilian\r\nformat) corresponding to the date d.$DAYS( )d,p,w$d String expression representing a date. If omitted, it is assumed to be the value\r\nreturned by DATETIME().\r\nThe value for d must have computational type and should have character type.\r\nIf not, d is converted to character.\r\np One of the supported date/time patterns. If omitted, it is assumed to be the\r\nvalue 'YYYYMMDDHHMISS9999'.\r\np must have computational type and should have character type. If not, it is\r\nconverted to character.\r\nw An integer expression that defines a century window to be used to handle any\r\ntwo-digit year formats.\r\nv If the value is positive, such as 1950, it is treated as a year.\r\nv If negative or zero, the value specifies an offset to be subtracted from the\r\ncurrent, system-supplied year.\r\nv If omitted, w defaults to the value specified in the WINDOW compile-time\r\noption.\r\nExample\r\ndcl Date_format value ('MMDDYYYY') char;\r\ndcl Todays_date char(length(Date_format));\r\ndcl Sep2_1993 char(length(Date_format));\r\ndcl Days_of_July4_1993 fixed bin(31);\r\ndcl Msg char(100) varying;\r\ndcl Date_due char(length(Date_format));\r\nTodays_date = datetime(date_format); /* e.g. 06161993 */\r\nDays_of_July4_1993 = days('07041993','MMDDYYYY');\r\nSep2_1993 = daystodate(days_of_July4_1993 + 60, Date_format);\r\n/* 09021993 */\r\nDate_due = daystodate(days() + 60, Date_format);\r\n/* assuming today is July 4, 1993, this would be Sept. 2, 1993 */\r\nMsg = 'Please pay amount due on or before ' \\r\nsubstr(Date_due, 1, 2) \ '/' \\r\nsubstr(Date_due, 3,2) \ '/' \\r\nsubstr(Date_due, 5);\r\nThe allowed patterns are listed in Table 51 on page 396. For an explanation of\r\nLilian format, see ?Date/time built-in functions? on page 394.
DAYSTODATE = DAYSTODATE returns a nonvarying character string containing the date in the\r\nform p that corresponds to d days (in Lilian format).$DAYSTODATE ( d ),p,w$d The number of days (in Lilian format). d must have a computational type and\r\nis converted to FIXED BINARY(31,0) if necessary.\r\np One of the supported date/time patterns.\r\nIf omitted, p is assumed to be the default date/time pattern\r\n'YYYYMMDDHHMISS999' (same as the default format returned by\r\nDATETIME).\r\nw An integer expression that defines a century window to be used to handle any\r\ntwo-digit year formats.\r\nv If the value is positive, such as 1950, it is treated as a year.\r\nv If negative or zero, the value specifies an offset to be subtracted from the\r\ncurrent, system-supplied year.\r\nv If omitted, w defaults to the value specified in the WINDOW compile-time\r\noption.\r\nThe allowed patterns are listed in Table 51 on page 396. For an explanation of\r\nLilian format, see ?Date/time built-in functions? on page 394.\r\nSee ?DAYS? on page 454 for an example using DAYSTODATE.
DAYSTOSECS = DAYSTOSECS returns a FLOAT BINARY(53) value that is the number of seconds\r\ncorresponding to the number of days x.$DAYSTOSECS(x)$x Expression.\r\nx must have a computational type and is converted to FIXED BINARY(31,0) if\r\nnecessary.\r\nDAYSTOSECS(x) is the same as x*(24*60*60).
DECIMAL = DECIMAL returns the decimal value of x, with a precision specified by p and q.\r\nThe result has the mode and scale of x.$DECIMAL(x ),p,q$Abbreviation: DEC\r\nx Reference.\r\np Restricted expression specifying the number of digits to be maintained\r\nthroughout the operation.\r\nq Restricted expression specifying the scaling factor of the result. For a\r\nfixed-point result, if p is given and q is omitted, a scaling factor of zero is\r\nassumed. For a floating-point result, q must be omitted.\r\nIf both p and q are omitted, the precision of the result is determined from the rules\r\nfor base conversion.
DIMENSION = DIMENSION returns a FIXED BINARY value specifying the current extent of\r\ndimension y of x.$DIMENSION(x ),y$Abbreviation: DIM\r\nx Array reference. x must not have less than y dimensions.\r\ny Expression specifying a particular dimension of x. If necessary, y is converted\r\nto a FIXED BINARY(31,0). y must be greater than or equal to 1. If y is not\r\nsupplied, it defaults to 1.\r\ny can be omitted only if the array is one-dimensional.\r\nIf y exceeds the number of dimensions of x, the DIMENSION function returns an\r\nundefined value.\r\nUnder the CMPAT(V3) compiler option, DIMENSION returns a FIXED BIN(63)\r\nvalue. Under the CMPAT(V2) and CMPAT(LE) compiler options, DIMENSION\r\nreturns a FIXED BIN(31) value, while under the CMPAT(V1) compiler option, it\r\nreturns a FIXED BIN(15) value.\r\nUsing LBOUND and HBOUND instead of DIMENSION is recommended.
DIVIDE = DIVIDE returns the quotient of x/y with a precision specified by p and q. The base,\r\nscale, and mode of the result follow the rules for expression evaluation unless\r\noverruled by the PRECTYPE compiler option.$DIVIDE(x,y,p ),q$x Expression.\r\ny Expression. If y = 0, the ZERODIVIDE condition is raised.\r\np Restricted expression specifying the number of digits to be maintained\r\nthroughout the operation.\r\nq Restricted expression specifying the scaling factor of the result. For a\r\nfixed-point result, if q is omitted, a scaling factor of zero is the default. For a\r\nfloating-point result, q must be omitted.
EDIT = EDIT returns a character string of length LENGTH(y). Its value is equivalent to\r\nwhat would result if x were assigned to a variable declared with the picture\r\nspecification given by y.\r\nFor the valid picture characters, refer to Chapter 15, ?Picture specification\r\ncharacters,? on page 337.$EDIT(x,y)$x Expression\r\nx must have computational type.\r\ny String expression.\r\ny must have character type and must contain picture characters that are valid\r\nfor a PICTURE data item. If y does not contain a valid picture specification, the\r\nERROR condition is raised.\r\nExample\r\ndcl pic1 char(9) init ('ZZZZZZZZ9');\r\ndcl pic2 char(7) init ('ZZ9V.99');\r\ndcl num fixed dec (9) init (123456789);\r\nz = edit (num, pic1); /* '123456789' */\r\nz = edit (num, pic2); /* '789.00' */\r\nz = edit (num, substr(pic1,8)); /* '89' */\r\nz = edit (num, substr(pic2,1,5)); /* '789.' */\r\nz = edit (num, substr(pic1,7,3)); /* '789' */\r\nz = edit (num, substr(pic2,3,5)); /* '9.00' */\r\nz = edit ('1', substr(pic1,7,3)); /* ' 1' */\r\nz = edit ('PL/I', 'AAXA'); /* 'PL/I' */\r\nz = edit ('PL/I', 'AAAA'); /* raises conversion */\r\nIf x cannot be edited into the picture specification given by y, the conditions raised\r\nare those that would be raised if x were assigned to a PICTURE data item which\r\nhas the same picture specification contained in y.
EMPTY = EMPTY returns an area of zero extent. It can be used to free all allocations in an\r\narea.$EMPTY()$The value of this function is assigned to an area variable when the variable is\r\nallocated. Consider this example:\r\ndeclare A area,\r\nI based (P),\r\nJ based (Q);\r\nallocate I in(A), J in (A);\r\nA = empty();\r\n/* Equivalent to: free I in (A), J in (A); */
ENDFILE = ENDFILE returns a '1'B when the end of the file is reached; '0'B if the end is not\r\nreached. If the file is not open, the ERROR condition is raised.$ENDFILE(x)$x File reference.\r\nENDFILE can be used to detect the end-of-file condition for bytestream files; for\r\nexample, files that require the use of the FILEREAD built-in function.
ENTRYADDR = ENTRYADDR returns a pointer value that is the address of the first executed\r\ninstruction if the entry x is invoked. The entry x must represent a non-nested\r\nprocedure.$ENTRYADDR(x)$x Entry reference.\r\nIf x is a fetchable entry constant, it must be fetched before ENTRYADDR is\r\nexecuted. However, if x has been released, then ENTRYADDR will return\r\nSYSNULL.\r\nENTRYADDR pseudovariable\r\nThe ENTRYADDR pseudovariable initializes an entry variable, x, with the address\r\nof the entry to be invoked.\r\nx Entry reference.\r\nNote: If the address supplied to the ENTRYADDR variable is the address of an\r\ninternal procedure, the results are unpredictable.\r\nENTRYADDR pseudovariable
EPSILON = EPSILON returns a floating-point value that is the spacing between x and the next\r\npositive number when x is 1. It has the base, mode, and precision of x.$EPSILON(x)$x REAL FLOAT expression.\r\nEPSILON(x) is a constant and can be used in restricted expressions.
ERF = ERF returns a real floating-point value that is an approximation of the error\r\nfunction of x.$ERF(x)$x Real expression.\r\nThe result has the base and precision of x, and a value given by:\r\n(2/ '(?) ) ?x0 EXP(-(t\r\n2 ))dt
ERFC = ERFC returns a real floating-point value that is an approximation of the\r\ncomplement of the error function of x.$ERFC(x)$x Real expression.\r\nThe result has the base and precision of x, and a value given by:\r\n1 - ERF(x)
EXP = EXP returns a floating-point value that is an approximation of the base, e, of the\r\nnatural logarithm system raised to the power x.$EXP(x)$x Expression.\r\nThe result has the base, mode, and precision of x.
EXPONENT = EXPONENT returns a FIXED BINARY(31,0) value that is the exponent part of x.$EXPONENT(x)$x Expression. x must be declared as REAL FLOAT.\r\nEXPONENT(x) is not the ?mathematical? exponent of x. If x = 0,\r\nEXPONENT(x) = 0. For other values of x, EXPONENT(x) is the unique number e\r\nsuch that:\r\n(e-1) e\r\nradix(x) <= abs(x) < radix(x)\r\nConsequently, EXPONENT(1e0) equals 1 and not 0.
FILEDDINT = FILEDDINT returns a FIXED BIN(31) value that is the value of attribute c for file x.$FILEDDINT(x,c)$x File reference.\r\nc Character string that holds the attribute to be queried.\r\nWhen using FILEDDINT, the following are valid values for c:\r\nblksize\r\nbufsize\r\ndelay\r\nfilesize\r\nkeylen\r\nkeyloc\r\nrecsize\r\nretry\r\nThe ERROR condition with oncode 1010 is raised when the file is not open or the\r\nattribute is invalid for the file being queried.\r\nFILEDDINT(x,'BLKSIZE') is valid only on z/OS. FILEDDINT(x,'BLKSIZE') will\r\nreturn the blocksize for a CONSECUTIVE file. It will return 0 for an HFS file and\r\nwill return 0 for a VSAM file.\r\nFILEDDINT(x,'FILESIZE') will, on z/OS, return a value of 0 except for HFS files.\r\nFILEDDINT(x,'KEYLOC') and FILEDDINT(x,'KEYLEN') are valid only for VSAM\r\nKSDS files.
FILEDDTEST = FILEDDTEST returns a FIXED BIN(31) value that holds the value 1 if the attribute\r\nc applies to file x. Otherwise, a value of 0 is returned.$FILEDDTEST(x,c)$x File reference.\r\nc Character string that holds the attribute to be queried.\r\nWhen using FILEDDTEST, the following are valid values for c:\r\nappend\r\nbkwd\r\nctlasa\r\ndelimit\r\ndescendkey\r\ngenkey\r\ngraphic\r\nlrmskip\r\nprint\r\nprompt\r\nscalarvarying\r\nskip0\r\nThe ERROR condition with oncode 1010 is raised when the file is not open or the\r\nattribute is invalid for the file being queried.
FILEDDWORD = FILEDDWORD returns a character string that is the value of the attribute c for file\r\nx.$FILEDDWORD(x,c)$x File reference.\r\nc Character string that holds the attribute to be queried.\r\nWhen using FILEDDWORD, the following are valid options for c:\r\naccess\r\namthd\r\naction\r\ncharset\r\nfilename\r\norganization\r\nputpage\r\nrecfm\r\nshare\r\ntype\r\ntypef\r\nThese options return the following values:\r\nv ACCESS returns SEQUENTIAL or DIRECT.\r\nv ACTION returns INPUT, OUTPUT, or UPDATE.\r\nv AMTHD returns VSAM KSDS, VSAM ESDS or VSAM RRDS on the z/OS\r\nplatform and FILESYS, DDM, BTRIEVE or ISAM on the Windows or AIX\r\nplatforms.\r\nv CHARSET returns ASCII or EBCDIC.\r\nv On the z/OS platform, FILENAME returns the fully qualified path name for\r\nHFS files and the MVS dataset name for all other files except it returns the value\r\n'NULLFILE' for files specified with either DSN=NULLFILE and DD DUMMY.\r\nFor a MVS dataset that is a member of a PDS or PDSE, the name returned\r\nincludes the member name. On the Windows and AIX platforms, it returns the\r\nfully qualified path name of the file .\r\nv ORGANIZATION returns CONSECUTIVE, RELATIVE, REGIONAL(1) or\r\nINDEXED.\r\nv RECFM returns the appropriate record format setting for the file, and U for\r\nVSAM files. This option is only valid on z/OS.\r\nv SHARE returns NONE, READ or ALL.\r\nv TYPE returns RECORD or STREAM.\r\nv TYPEF returns the type of the native file.\r\nThe ERROR condition with oncode 1010 is raised when the file is not open or the\r\nattribute is invalid for the file being queried.\r\nFILEDDWORD(x,'RECFM') is valid only under z/OS.
FILEID = FILEID returns a FIXED BIN(31) value that is the system token for a PL/I file\r\nconstant or variable.$FILEID(x)$x File reference.\r\nThis token should not be used for any purpose which could be accomplished by a\r\nPL/I statement.\r\nOn z/OS, the token holds the address of the DCB associated with a RECORD or\r\nSTREAM file or of the ACB associated with a VSAM RECORD file. The token is\r\nnot valid for other files. Note: the DCB or ACB address is provided so that\r\napplications can read the DCB or ACB. The DCB and ACB must not be altered.\r\nThe ERROR condition with oncode 1010 is raised when the file is not open.
FILEOPEN = FILEOPEN returns '1'B if the file x is open and '0'B if the file is not open.$FILEOPEN(x)$x File reference.
FILEREAD = FILEREAD attempts to read z storage units (bytes) from file x into location y. It\r\nreturns the number of storage units actually read.$FILEREAD(x,y,z)$x File reference.\r\ny Expression with type POINTER or OFFSET. If the type is OFFSET, the\r\nexpression must be an OFFSET variable declared with the AREA attribute.\r\nz Expression with computational type that is converted to FIXED BIN(31,0).\r\nFILEREAD can read only TYPE(U) files.
FILESEEK = FILESEEK changes the current file position associated with file x to a new location\r\nwithin the file. The next operation on the file takes place at the new location. It\r\nalso returns a FIXED BIN(31) value that is 0 if the change in file position is\r\nsuccessful and non-zero otherwise. FILESEEK is equivalent to the fseek function in\r\nC.$FILESEEK(x,y,z)$x File reference.\r\ny A FIXED BINARY(31) value that indicates the number of positions the file\r\npointer is to be moved relative to z.\r\nz A FIXED BINARY(31) value that indicates the origin from which the file\r\npointer is to be moved. The following values are valid:\r\n-1 Beginning of the file\r\n0 Current position of the file pointer\r\n1 End of the file.\r\nFILESEEK can be used only on TYPE(U) files.
FILETELL = FILETELL returns a FIXED BINARY(31) value indicating the current position of the\r\nfile x. The value returned is an offset relative to the beginning of the file.\r\nFILETELL is equivalent to the ftell function in C.$FILETELL(x)$x File reference.\r\nFILETELL can be used only on TYPE(U) files.
FILEWRITE = FILEWRITE attempts to write z storage units (bytes) to file x from location y It\r\nreturns the number of storage units actually written.$FILEWRITE(x,y,z)$x File reference.\r\ny Expression with type POINTER or OFFSET. If the type is OFFSET, the\r\nexpression must be an OFFSET variable declared with the AREA attribute.\r\nz Expression with computational type that is converted to FIXED BIN(31,0).\r\nFILEWRITE can write only to TYPE(U) files.
FIXED = FIXED returns the fixed-point value of x, with a precision specified by p and q. The\r\nresult has the base and mode of x.$FIXED(x ),p,q$x Expression.\r\np Restricted expression that specifies the total number of digits in the result. It\r\nmust not exceed the implementation limit.\r\nq Restricted expression that specifies the scaling factor of the result. If q is\r\nomitted, a scaling factor of zero is assumed.\r\nIf both p and q are omitted, the default values, (15,0) for a binary result or (5,0) for\r\na decimal result, are used.
FIXEDBIN = FIXEDBIN returns a FIXED BIN value with precision and scale derived from the\r\nsource unless explicitly specified as parameters to the function.$FIXEDBIN(x ),p,q$x Expression.\r\np Restricted expression that specifies the total number of digits in the result. It\r\nmust not exceed the implementation limit.\r\nq Restricted expression that specifies the scaling factor of the result. If q is\r\nomitted, a scaling factor of zero is assumed.\r\nIf both p and q are omitted, the precision of the result is determined from the\r\nsource according to this table:\r\nsource result\r\nFIXED BIN(p,q) FIXED BIN(p,q)\r\nFIXED DEC(p,q) FIXED BIN(r,s)\r\nwhere r = min(M,1+CEIL(p*3.32))\r\nand s = CEIL(ABS(q*3.32))*SIGN(q)\r\nFLOAT BIN(p) FIXED BIN(p,0)\r\nFLOAT DEC(p) FIXED BIN(r,0)\r\nwhere r = min(M,CEIL(p*3.32))\r\nBIT FIXED BIN(M,0)\r\nCHAR, GRAPHIC or\r\nWIDECHAR\r\nFIXED BIN(r,0)\r\nwhere r = min(M,1+CEIL(N*3.32))
FIXEDDEC = FIXEDDEC returns a FIXED DEC value with precision and scale derived from the\r\nsource unless explicitly specified as parameters to the function.$FIXEDDEC(x ),p,q$x Expression.\r\np Restricted expression that specifies the total number of digits in the result. It\r\nmust not exceed the implementation limit.\r\nq Restricted expression that specifies the scaling factor of the result. If q is\r\nomitted, a scaling factor of zero is assumed.\r\nIf both p and q are omitted, the precision of the result is determined from the\r\nsource according to this table:\r\nsource result\r\nFIXED BIN(p,q) FIXED DEC(r,s)\r\nwhere r = min(N,1+CEIL(p/3.32))\r\nand s=CEIL(ABS(q/3.32))*SIGN(q)\r\nFIXED DEC(p,q) FIXED DEC(p,q)\r\nFLOAT BIN(p) FIXED DEC(r,0)\r\nwhere r = min(N,CEIL(p/3.32)\r\nFLOAT DEC(p) FIXED DEC(p,0)\r\nBIT FIXED DEC(r,0)\r\nwhere where r = min(N,1+CEIL(M/3.32))\r\nCHAR, GRAPHIC or\r\nWIDECHAR\r\nFIXED DEC(N,0)
FLOAT = FLOAT returns the approximate floating-point value of x, with a precision\r\nspecified by p. The result has the base and mode of x.$FLOAT(x ),p$x Expression.\r\np Restricted expression that specifies the minimum number of digits in the\r\nresult.\r\nIf p is omitted, the precision of the result is determined from the rules for base\r\nconversion.\r\nIf p is omitted, the default value, 15 for a binary result or 5 for a decimal\r\nresult, is used.
FLOATBIN = FLOATBIN returns a FLOAT BIN value with precision derived from the source\r\nunless explicitly specified as a parameter to the function.$FLOATBIN(x ),p$x Expression.\r\np Restricted expression that specifies the total number of digits in the result. It\r\nmust not exceed the implementation limit.\r\nIf p is omitted, the precision of the result is determined from the source according\r\nto this table:\r\nsource result\r\nFIXED BIN(p,q) FLOAT BIN(p)\r\nFIXED DEC(p,q) FLOAT BIN(r)\r\nwhere r = CEIL(p*3.32)\r\nFLOAT BIN(p) FLOAT BIN(p)\r\nFLOAT DEC(p) FLOAT BIN(r)\r\nwhere r = CEIL(p*3.32)\r\nBIT FLOAT BIN(M)\r\nCHAR, GRAPHIC or\r\nWIDECHAR\r\nFLOAT BIN(r)\r\nwhere r = CEIL(N*3.32)
FLOATDEC = FLOATDEC returns a FLOAT DEC value with precision derived from the source\r\nunless explicitly specified as a parameter to the function.$FLOATDEC(x ),p$x Expression.\r\np Restricted expression that specifies the total number of digits in the result. It\r\nmust not exceed the implementation limit.\r\nIf p is omitted, the precision of the result is determined from the source according\r\nto this table:\r\nsource result\r\nFIXED BIN(p,q) FLOAT DEC(r)\r\nwhere r = CEIL(p/3.32)\r\nFIXED DEC(p,q) FLOAT DEC(p)\r\nFLOAT BIN(p) FLOAT DEC(r)\r\nwhere r = CEIL(p/3.32)\r\nFLOAT DEC(p) FLOAT DEC(p)\r\nBIT FLOAT DEC(r)\r\nwhere r = CEIL(M/3.32)\r\nCHAR, GRAPHIC or\r\nWIDECHAR\r\nFLOAT DEC(N)
FLOOR = FLOOR returns the largest integer value less than or equal to x.$FLOOR(x)$x Real expression.\r\nThe mode, base, scale, and precision of the result match the argument. Except\r\nwhen x is fixed-point with precision (p,q), the precision of the result is given by:\r\n(min(n,max(p-q+1,1)),0)\r\nwhere n is the maximum number of digits allowed and is N for FIXED DECIMAL\r\nor M for FIXED BINARY.
GAMMA = GAMMA is an approximation of the gamma of x, as given by the following\r\nequation:\r\ngamma(x) = ??0 (u\r\nx-1)(e-x)du\r\nGAMMA returns a floating-point value that has the base, mode, and precision of x.$GAMMA(x)$x Real expression. The value of x must be greater than zero.
GETENV = GETENV returns a character value representing a specified environment variable.$GETENV(x)$x Expression naming an environment variable.
GRAPHIC = GRAPHIC can be used to explicitly convert character (or mixed character) data to\r\nGRAPHIC data. All other data first converts to character, and then to the\r\nGRAPHIC data type.\r\nGRAPHIC returns the graphic value of x, with a length in graphic symbols\r\nspecified by y.\r\nCharacters convert to graphics. The content of x is checked for validity during\r\nconversion, using the same rules as for checking graphic and mixed character\r\nconstants.$GRAPHIC(x ),y$x Expression. When x is GRAPHIC, it is subject to a length change, with\r\napplicable padding or truncation. When x is nongraphic, it is converted to\r\ncharacter, if necessary. SBCS characters are converted to equivalent DBCS\r\ncharacters.\r\ny Expression. If necessary, y is converted to a real fixed-point binary value. If y is\r\nomitted, the length is determined by the rules for type conversion.\r\ny must not be negative.\r\nIf y = 0, the result is the null graphic string.\r\nThe following rules apply:\r\nv If y is greater than the length needed to contain the graphic string, the result\r\nis padded with graphic blanks.\r\nv If y is less than the length needed to contain the graphic string, the result is\r\ntruncated.\r\nExample 1\r\nConversion from CHARACTER to GRAPHIC, where the target is long enough to\r\ncontain the result:\r\ndcl X char (11) varying;\r\ndcl A graphic (11);\r\nA = graphic(X,8);\r\nFor X with values Intermediate Result A is assigned\r\nABCDEFGHIJ\r\n123\r\n123A.B.C\r\n.A.B.C.D.E.F.G.H.I.J\r\n.1.2.3\r\n.1.2.3.A.B.C\r\n.A.B.C.D.E.F.G.H.b.b.b\r\n.1.2.3.b.b.b.b.b.b.b.b\r\n.1.2.3.A.B.C.b.b.b.b.b\r\nwhere .b is a DBCS blank.\r\nExample 2\r\nConversion from CHARACTER to GRAPHIC, where the target is too short to\r\ncontain the result:\r\ndcl X char (10) varying;\r\ndcl A graphic (8);\r\nA = graphic(X);\r\nFor X with value Intermediate Result A is assigned\r\nABCDEFGHIJ .A.B.C.D.E.F.G.H.I.J .A.B.C.D.E.F.G.H
HANDLE = HANDLE returns a handle to the typed structure x.$HANDLE(x)$x Typed structure.
HBOUND = HBOUND returns a FIXED BINARY value specifying the current upper bound of\r\ndimension y of x.$HBOUND(x ),y$x Array reference. x must not have less than y dimensions.\r\ny Expression specifying a particular dimension of x. If necessary, y is converted\r\nto FIXED BINARY(31,0). y must be greater than or equal to 1. If y is not\r\nsupplied, it defaults to 1.\r\ny can be omitted only if the array is one-dimensional.\r\nUnder the CMPAT(V3) compiler option, HBOUND returns a FIXED BIN(63) value.\r\nUnder the CMPAT(V2) and CMPAT(LE) compiler options, HBOUND returns a\r\nFIXED BIN(31) value, while under the CMPAT(V1) compiler option, it returns a\r\nFIXED BIN(15) value.
HBOUNDACROSS = HBOUNDACROSS returns a FIXED BINARY value specifying the current upper\r\nbound of a DIMACROSS reference x.$HBOUNDACROSS(x)$x DIMACROSS reference.\r\nUnder the CMPAT(V3) compiler option, HBOUNDACROSS returns a FIXED\r\nBIN(63) value. Under the CMPAT(V2) and CMPAT(LE) compiler options,\r\nHBOUNDACROSS returns a FIXED BIN(31) value, while under the CMPAT(V1)\r\ncompiler option, it returns a FIXED BIN(15) value.\r\nThe following example shows the use of HBOUNDACROSS:\r\ndcl jx fixed bin(31);\r\ndcl\r\n1 a,\r\n2 b fixed bin,\r\n2 c fixed bin;\r\ndcl 1 xa( 100 ) like a dimacross;\r\n...\r\ndo jx = 1 to hboundacross(xa);\r\na = xa, by dimacross(jx);\r\n...\r\nend;
HEX = HEX returns a character string that is the hexadecimal representation of the storage\r\nthat contains x.$HEX(x ),z$HEX(x) returns a character string of length 2 * size(x).\r\nHEX(x,z) returns a character string that contains x with the character z inserted\r\nbetween every set of eight characters in the output string. Its length is 2 * size(x)\r\n+ ((size(x) - 1)/4).\r\nUnder the compiler option USAGE(HEX(CSTG)), the length used in the above\r\ncalculations is based, for VARYING and VARYINGZ strings, on cstg(x) rather\r\nthan on stg(x).\r\nx Expression that represents any variable. The whole number of bytes that\r\ncontain x is converted to hexadecimal.\r\nz Expression. If specified, z must have the type CHARACTER(1) NONVARYING.\r\nInteger, offset and pointer values will be presented in bigendian form.\r\nExample 1\r\ndcl Sweet char(5) init('Sweet');\r\ndcl Sixteen fixed bin(31) init(16) littleendian;\r\ndcl XSweet char(size(Sweet)*2+(size(Sweet)-1)/4);\r\ndcl XSixteen char(size(Sixteen)*2+(size(Sixteen)-1)/4);\r\nXSweet = hex(Sweet,'-');\r\n/* '53776565-74' */\r\nXSweet = heximage(addr(Sweet),length(Sweet),'-');\r\n/* '53776565-74' */\r\nXSixteen = hex(Sixteen,'-');\r\n/* '00000010' - bytes reversed */\r\nXSixteen = heximage(addr(Sixteen),stg(Sixteen),'-');\r\n/* '10000000' - bytes NOT reversed */\r\nExample 2\r\ndcl X fixed bin(15) littleendian;\r\ndcl Y fixed bin(15) bigendian;\r\nX = 258; /* stored as '0201'B4 */\r\nY = 258; /* stored as '0102'B4 */\r\ndisplay (hex(X)); /* displays 0102 */\r\ndisplay (hex(Y)); /* displays 0102 */\r\ndisplay (heximage( addr(X), stg(X) )); /* displays 0201 */\r\ndisplay (heximage( addr(Y), stg(Y) )); /* displays 0102 */\r\nNote: This function does not return an exact image of x in storage. If an exact\r\nimage is required, use the HEXIMAGE built-in function.
HEXIMAGE = HEXIMAGE returns a character string that is the hexadecimal representation of the\r\nstorage at a specified location.$HEXIMAGE(p,n ),z$HEXIMAGE(p,n) returns a character string that is the hexadecimal representation\r\nof n bytes of storage at location p. Its length is 2 * n..\r\nHEXIMAGE(p,n,z) returns a character string that is the hexadecimal representation\r\nof n bytes of storage at location p with character z inserted between every set of\r\neight characters in the output string. Its length is (2 * n) + ((n - 1)/4).\r\np Restricted expression that must have a locator type (POINTER or OFFSET). If p\r\nis OFFSET, it must have the AREA attribute.\r\nn Expression. n must have a computational type and is converted to FIXED\r\nBINARY(31,0).\r\nz If specified, z must have the type CHARACTER(1) NONVARYING.\r\nFor examples of the HEXIMAGE built-in function, see ?HEX? on page 493.
HIGH = HIGH returns a character string of length x, where each character is the highest\r\ncharacter in the collating sequence (hexadecimal FF).$HIGH(x)$x Expression. If necessary, x is converted to a positive real fixed-point binary\r\nvalue. If x = 0, the result is the null character string.
HUGE = HUGE returns a floating-point value that is the largest positive value x can\r\nassume. It has the base, mode, and precision of x.$HUGE(x)$x Expression. x must have the attributes REAL FLOAT.\r\nHUGE(x) is a constant and can be used in restricted expressions.
IAND = IAND returns the logical AND of its arguments$IAND( x, y )$x and y\r\nExpressions that must have a computational type.\r\nIf any argument is not REAL FIXED BIN(p,0), then it is converted to SIGNED\r\nREAL FIXED BIN(p,0).\r\nIf any argument is SIGNED, then any UNSIGNED arguments are converted to\r\nSIGNED.\r\nThe result is REAL FIXED BIN( max(p1,p2,...), 0 ). It is UNSIGNED if all the\r\narguments are UNSIGNED.
IEOR = IEOR returns the logical exclusive-OR of x and y. The result is unsigned if all\r\narguments are unsigned.$IEOR(x,y)$x and y\r\nExpressions that must have a computational type.\r\nIf any argument is not REAL FIXED BIN(p,0), then it is converted to SIGNED\r\nREAL FIXED BIN(p,0).\r\nIf any argument is SIGNED, then any UNSIGNED arguments are converted to\r\nSIGNED.\r\nThe result is REAL FIXED BIN( max(p1,p2,...), 0 ). It is UNSIGNED if all the\r\narguments are UNSIGNED.
IMAG = IMAG returns the imaginary part of x. The mode of the result is real and has the\r\nbase, scale, and precision of x.$IMAG(x)$x Expression. If x is real, it is converted to complex, and an appropriate zero\r\nvalue is returned.\r\nIMAG pseudovariable\r\nThe IMAG pseudovariable assigns a real value or the real part of a complex value\r\nto the coefficient of the imaginary part of x.\r\nx Complex reference.\r\nIMAG pseudovariable
INDEX = INDEX returns an unscaled REAL FIXED BINARY value indicating the starting\r\nposition within x of a substring identical to y. You can also specify the location\r\nwithin x where processing begins.$INDEX(x,y ),n$x String-expression to be searched.\r\ny Target string-expression of the search.\r\nn n specifies the location within x at which to begin processing. It must have a\r\ncomputational type and is converted to FIXED BINARY(31,0).\r\nIf y does not occur in x, or if either x or y have zero length, the value zero is\r\nreturned.\r\nIf n is less than 1 or if n is greater than 1 + length(x), the STRINGRANGE\r\ncondition will be raised, and the result will be 0.\r\nThe BIFPREC compiler option determines the precision of the result returned.\r\nExample\r\ndcl tractatus char\r\nvalue( 'Wovon man nicht sprechen kann, ' \\r\n'darueber muss man schweigen.' );\r\ndcl pos fixed bin init(1);\r\npos = index( tractatus, 'man', pos+1 ); /* pos = 07 */\r\npos = index( tractatus, 'man', pos+1 ); /* pos = 46 */\r\npos = index( tractatus, 'man', pos+1 ); /* pos = 00 */
INDICATORS = INDICATORS returns a FIXED BIN value giving the number of the elements at the\r\nnext logical level in a structure x.$INDICATORS(x)$x Expression.\r\nx must be a structure reference.\r\nINDICATORS(x) always forms a restricted expression.\r\nThe INDICATORS built-in function is useful in declaring an indicator array for use\r\nin SQL statements.
INOT = INOT returns the logical NOT of x.$INOT(x)$x Expression. x must have a computational type.\r\nIf x is REAL FIXED BIN(p,0), then the result is REAL FIXED BIN(p,0) and it is\r\nUNSIGNED if x is UNSIGNED. Otherwise, x is converted to SIGNED REAL FIXED\r\nBIN(p,0) and the result has the same attributes.\r\nAlthough INOT(x) has the opposite sign of x, INOT(x) is not the same as ?x.\r\nExamples\r\ninot(0) /* produces ?1 */\r\ninot(?1) /* produces 0 */\r\ninot(+1) /* produces ?2 */
IOR = IOR returns the logical OR of its arguments.$IOR( x, y )$x and y\r\nExpressions that must have a computational type.\r\nIf any argument is not REAL FIXED BIN(p,0), then it is converted to SIGNED\r\nREAL FIXED BIN(p,0).\r\nIf any argument is SIGNED, then any UNSIGNED arguments are converted to\r\nSIGNED.\r\nThe result is REAL FIXED BIN( max(p1,p2,...), 0 ). It is UNSIGNED if all the\r\narguments are UNSIGNED.
ISFINITE = ISFINITE returns a '1'B if if the argument with which it is invoked is not a NAN\r\nand not positive or negative infinity. Otherwise it returns a '0'B.$ISFINITE(x)$x REAL FLOAT DECIMAL expression.\r\nThe FLOAT(DFP) compiler option must be in effect.\r\nNo floating-point exceptions will be raised no matter what the format of the\r\nargument.
ISIGNED = ISIGNED(x) returns the result of casting x to a signed integer value without\r\nchanging its bit pattern.$ISIGNED(x)$x Expression. x must have a computational type.\r\nIf x is not an integer, that is, if x is not REAL FIXED BIN with zero scale factor,\r\nthen it is converted to REAL FIXED BIN(p,0).\r\nISIGNED( x ) returns, for integer x, a value with the same bit pattern as x but the\r\nattributes SIGNED FIXED BIN(p).\r\nIf x is UNSIGNED, p is given by:\r\nIf precision(x) = 8, 16, 32 or 64, then p = precision(x) - 1 else p = precision(x)\r\nIf x is SIGNED, p is equal to the precision of x.\r\nExamples\r\nISIGNED('ff_ff_ff_ff'xu) equals the SIGNED FIXED BIN(31) value -1.
ISINF = ISINF returns a '1'B if if the argument with which it is invoked is an infinity.\r\nOtherwise it returns a '0'B.$ISINF(x)$x REAL FLOAT DECIMAL expression.\r\nThe FLOAT(DFP) compiler option must be in effect.\r\nNo floating-point exceptions will be raised no matter what the format of the\r\nargument.
ISLL = ISLL(x,n) returns the result of logically shifting x to the left by n places, and\r\npadding on the right with zeroes.$ISLL(x,n)$x Expression. x must have a computational type.\r\nn Expression. n must have a computational type.\r\nIf x is REAL FIXED BIN(p,0) and SIGNED, the result is SIGNED REAL FIXED\r\nBIN(r,0) where if p <= M1, r = M1; if p > M1, r = M2.\r\nIf x is REAL FIXED BIN(p,0) and UNSIGNED, the result is UNSIGNED REAL\r\nFIXED BIN(r+1,0) where if p <= (M1+1), r = (M1+1); if p > M1, r = (M2+1).\r\nOtherwise, x is converted to SIGNED REAL FIXED BIN(p,0) and the result has the\r\nsame attributes as above.\r\nIf n is negative or if n is greater than r, the result is undefined.\r\nNote: Unlike RAISE2(x,n), ISLL(x,n) can have a different sign than x does.\r\nExamples\r\nisll(+6,1) /* produces 12 */\r\nisll(2147483645,1) /* produces ?6 */
ISMAIN = ISMAIN() returns a '1'B if the procedure in which it is invoked has the\r\nOPTIONS(MAIN) attribute. Otherwise it returns a '0'B.$ISMAIN ( )$null
ISNAN = ISNAN returns a '1'B if if the argument with which it is invoked is a NAN.\r\nOtherwise it returns a '0'B.$ISNAN(x)$x REAL FLOAT DECIMAL expression.\r\nThe FLOAT(DFP) compiler option must be in effect.\r\nNo floating-point exceptions will be raised no matter what the format of the\r\nargument.
ISNORMAL = ISNORMAL returns a '1'B if if the argument with which it is invoked is not a zero,\r\nsubnormal, infinity or NaN. Otherwise it returns a '0'B.$ISNORMAL(x)$x REAL FLOAT DECIMAL expression.\r\nThe FLOAT(DFP) compiler option must be in effect.\r\nNo floating-point exceptions will be raised no matter what the format of the\r\nargument.
ISRL = ISRL(x,n) returns the result of logically shifting x to the right by n places, and\r\npadding on the left with zeroes.$ISRL(x,n)$x Expression. x must have a computational type.\r\nn Expression. n must have a computational type.\r\nIf x is REAL FIXED BIN(p,0) and:\r\nv x is SIGNED, then the result is SIGNED REAL FIXED BIN(p,0).\r\nv x is UNSIGNED, the result is UNSIGNED REAL FIXED BIN(p,0).\r\nOtherwise, x is converted to SIGNED REAL FIXED BIN(p,0) and the result has the\r\nsame attributes.\r\nThe result is undefined if n is negative or if n is greater than M.\r\nIf x is nonnegative, ISRL(x,n) is equivalent to LOWER2(x,n); if x is negative,\r\nISRL(x,n) is positive, unless n=0.\r\nExamples\r\nisrl(+6,1) /* produces 3 */\r\nisrl(?6,1) /* produces 2147483645 */
ISZERO = ISZERO returns a '1'B if if the argument with which it is invoked is a zero.\r\nOtherwise it returns a '0'B.$ISZERO(x)$x REAL FLOAT DECIMAL expression.\r\nThe FLOAT(DFP) compiler option must be in effect.\r\nNo floating-point exceptions will be raised no matter what the format of the\r\nargument.
IUNSIGNED = IUNSIGNED(x) returns the result of casting x to an unsigned integer value without\r\nchanging its bit pattern.$IUNSIGNED(x)$x Expression. x must have a computational type.\r\nIf x is not an integer, that is, if x is not REAL FIXED BIN with zero scale factor,\r\nthen it is converted to REAL FIXED BIN(p,0).\r\nIUNSIGNED(x) returns, for integer x, a value with the same bit pattern as x but\r\nthe attributes UNSIGNED FIXED BIN(p).\r\nIf x is SIGNED, p is given by:\r\nIf precision(x) = 7, 15, 31 or 63, then p = precision(x) + 1 else p = precision(x)\r\nIf x is UNSIGNED, p is equal to the precision of x.\r\nExamples\r\nIUNSIGNED('ff_ff_ff_ff'xn) equals the largest UNSIGNED FIXED BIN(32) value.
LBOUND = LBOUND returns a FIXED BINARY value specifying the current lower bound of\r\ndimension y of x.$LBOUND(x ),y$x Array reference. x must not have less than y dimensions.\r\ny Expression specifying a particular dimension of x. If necessary, y is converted\r\nto FIXED BINARY(31,0). The value for y must be greater than or equal to 1.\r\nand if y is not supplied, it defaults to 1.\r\nThe value for y can be omitted only if the array is one-dimensional.\r\nUnder the CMPAT(V3) compiler option, LBOUND returns a FIXED BIN(63) value.\r\nUnder the CMPAT(V2) and CMPAT(LE) compiler options, LBOUND returns a\r\nFIXED BIN(31) value, while under the CMPAT(V1) compiler option, it returns a\r\nFIXED BIN(15) value.
LBOUNDACROSS = LBOUNDACROSS returns a FIXED BINARY value specifying the current lower\r\nbound of a DIMACROSS reference x.$LBOUNDACROSS(x)$x DIMACROSS reference.\r\nUnder the CMPAT(V3) compiler option, LBOUNDACROSS returns a FIXED\r\nBIN(63) value. Under the CMPAT(V2) and CMPAT(LE) compiler options,\r\nLBOUNDACROSS returns a FIXED BIN(31) value, while under the CMPAT(V1)\r\ncompiler option, it returns a FIXED BIN(15) value.
LEFT = LEFT returns a string that is the result of inserting string x at the left end of a\r\nstring with length n and padded on the right with the character z as needed.$LEFT(x,n ),z$x Expression. x must have a computational type and should have a character\r\ntype. If not, it is converted to CHARACTER.\r\nn Expression. n must have a computational type and should have a character\r\ntype. If n does not have the attributes FIXED BINARY(31,0), it is converted to\r\nthem.\r\nz Expression. If specified, z must have the type CHARACTER(1) NONVARYING\r\ntype.\r\nExample\r\ndcl Source char value('One Hundred SCIDS Marks');\r\ndcl Target char(30);\r\nTarget = left (Source, length(Target), '*');\r\n/* 'One Hundred SCIDS Marks*******' */\r\nIf z is omitted, a blank is used as the padding character.
LENGTH = LENGTH returns an unscaled REAL FIXED BINARY value specifying the current\r\nlength of x.$LENGTH(x)$x String-expression. If x is binary, it is converted to bit string; otherwise, any\r\nother conversion required is to character string.\r\nFor an example of the LENGTH built-in function, refer to ?MAXLENGTH? on\r\npage 531.\r\nThe BIFPREC compiler option determines the precision of the result returned.
LINENO = LINENO returns an unscaled REAL FIXED BINARY specifying the current line\r\nnumber of x.$LINENO(x)$x File-reference.\r\nThe file must be open and have the PRINT attribute. If the file is not open or does\r\nnot have the PRINT attribute, 0 is returned.\r\nThe BIFPREC compiler option determines the precision of the result returned.
LOCATION = LOCATION returns a FIXED BINARY value specifying the byte location of x\r\nwithin the level-1 structure or union that has member x.$LOCATION(x)$Abbreviation: LOC\r\nx Structure or union member name. If x is not a member of a structure or union,\r\na value of 0 is returned. If x has the BIT attribute, the value returned by\r\nLOCATION is the location of the byte that contains x.\r\nThe value for x must not be subscripted.\r\nLOCATION can be used in restricted expressions, with a limitation. The value for x\r\nmust be declared before y if LOC(x) is used to set either of the following:\r\nv The extent of a variable y that must have constant extents\r\nv The value of a variable y that must have a constant value.\r\nUnder the CMPAT(V3) compiler option, LOCATION returns a FIXED BIN(63)\r\nvalue. Under all other CMPAT options, it returns a FIXED BIN(31) value.\r\nExample\r\ndcl 1 Table static,\r\n2 Tab2loc fixed bin(15) nonasgn init(loc(Tab2)),\r\n/* location is 0; gets initialized to 8 */\r\n2 Tab3loc fixed bin(15) nonasgn init(loc(Tab3)),\r\n/* location is 2; gets initialized to 808 */\r\n2 Length fixed bin nonasgn init(loc(End)),\r\n/* location is 4 */\r\n2 * fixed bin,\r\n2 Tab2(20,20) fixed bin,\r\n/* location is 8 */\r\n2 Tab3(20,20) fixed bin,\r\n/* location is 808 */\r\n2 F2_loc fixed bin nonasgn init(loc(F2)),\r\n/* location is 1608; gets initialized to 1612 */\r\n2 F2_bitloc fixed bin nonasgn init(bitloc(F2)),\r\n/* location is 1610; gets initialized to 1 */\r\n2 Flags, /* location is 1612 */\r\n3 F1 bit(1),\r\n3 F2 bit(1), /* bitlocation is 1 */\r\n3 F3 bit(1),\r\n2 Bits(16) bit, /* location is 1613 */\r\n2 End char(0);
LOG = LOG returns a floating-point value that is an approximation of the natural\r\nlogarithm (the logarithm to the base e) of x. It has the base, mode, and precision of\r\nx.$LOG(x)$x Expression. x must be greater than zero.
LOGGAMMA = LOGGAMMA returns a floating-point value that is an approximation of the log of\r\ngamma of x. The gamma of x is given by the following equation:\r\ngamma(x) = ??0 (u\r\nx-1)(e-x)du\r\nLOGGAMMA has the base, mode, and precision of x.$LOGGAMMA(x)$x Real expression. The value of x must be greater than 0.
LOG2 = LOG2 returns a real floating-point value that is an approximation of the binary\r\nlogarithm (the logarithm to the base 2) of x. It has the base and precision of x.$LOG2(x)$x Real expression. The value of x must be greater than zero.
LOG10 = LOG10 returns a real floating-point value that is an approximation of the common\r\nlogarithm (the logarithm to the base 10) of x. It has the base and precision of x.$LOG10(x)$x Real expression. It must be greater than zero.
LOW = LOW returns a character string of length x, where each character is the lowest\r\ncharacter in the collating sequence (hexadecimal 00).$LOW(x)$x Expression. If necessary, x is converted to a positive real fixed-point binary\r\nvalue. If x = 0, the result is the null character string.
LOWERCASE = LOWERCASE returns a character string with all the alphabetic characters from A\r\nto Z converted to their lowercase equivalent.$LOWERCASE(x)$x Expression. If necessary, x is converted to character.\r\nLOWERCASE(x) is equivalent to\r\nTRANSLATE( x,\r\n'abcdefghijklmnopqrstuvwxyz',\r\n'ABCDEFGHIJKLMNOPQRSTUVWXYZ' )
LOWER2 = LOWER2(x,n) returns the value:\r\n-n\r\nfloor(x * (2 ))\r\nLOWER2(x,n) returns the value:\r\n-n\r\nfloor(x * (2 ))$LOWER2(x,n)$Note: LOWER2(x,n) is equivalent to the assembler SRA(x,n).\r\nx Expression. x must have a computational type.\r\nn Expression. n must have a computational type.\r\nIf x is SIGNED REAL FIXED BIN(p,0), then the result has the same attributes.\r\nOtherwise, x is converted to SIGNED REAL FIXED BIN(p,0) and the result has the\r\nsame attributes.\r\nThe result is undefined if n is negative or if n is greater than M.\r\nExamples\r\nlower2 (+6,1) /* Produces 3 */\r\nlower2 (-6,1) /* Produces -3 */\r\nlower2 (-7,1) /* Produces -4 */
MAX = MAX returns the largest value from a set of two or more expressions.$MAX( x, y )$x and y\r\nExpressions.\r\nAll the arguments must be real. The result is real, with the common base and scale\r\nof the arguments.\r\nIf the arguments are fixed-point with precisions:\r\n(p1,q1),(p2,q2),...,(pn,qn)\r\nthen the precision of the result is given by:\r\n(min(N,max(p1-q1,p2-q2,...,pn-qn) + max(q1,q2,...,qn)),max(q1,q2,...,qn))\r\nwhere N is the maximum number of digits allowed.\r\nIf the arguments are floating-point with precisions:\r\np1,p2,p3,...pn\r\nthen the precision of the result is given by:\r\nmax(p1,p2,p3,...pn)\r\nThe maximum number of arguments allowed is 64.
MAXEXP = MAXEXP returns a FIXED BINARY(31,0) value that is the maximum value that\r\nEXPONENT(x) could assume.$MAXEXP(x)$x Expression. x must have the REAL and FLOAT attributes.\r\nMAXEXP(x) is a constant and can be used in restricted expressions.\r\nExample (Intel Values)\r\nmaxexp(x) = 00128 for x float bin(p), p <= 21\r\nmaxexp(x) = 01024 for x float bin(p), 21 < p <= 53\r\nmaxexp(x) = 16384 for x float bin(p), 53 < p\r\nmaxexp(x) = 00128 for x float dec(p), p <= 6\r\nmaxexp(x) = 01024 for x float dec(p), 6 < p <= 16\r\nmaxexp(x) = 16384 for x float dec(p), 16 < p\r\nExample (AIX Values)\r\nmaxexp(x) = 0128 for x float bin(p), p <= 21\r\nmaxexp(x) = 1024 for x float bin(p), 21 < p <= 53\r\nmaxexp(x) = 1024 for x float bin(p), 53 < p\r\nmaxexp(x) = 0128 for x float dec(p), p <= 6\r\nmaxexp(x) = 1024 for x float dec(p), 6 < p <= 16\r\nmaxexp(x) = 1024 for x float dec(p), 16 < p\r\nExample (z/OS Hexdecimal Values)\r\nmaxexp(x) = 63 for x float bin(p), p <= 21\r\nmaxexp(x) = 63 for x float bin(p), 21 < p <= 53\r\nmaxexp(x) = 63 for x float bin(p), 53 < p\r\nmaxexp(x) = 63 for x float dec(p), p <= 6\r\nmaxexp(x) = 63 for x float dec(p), 6 < p <= 16\r\nmaxexp(x) = 63 for x float dec(p), 16 < p\r\nExample (z/OS IEEE Binary Floating Point Values)\r\nmaxexp(x) = 128 for x float bin(p), p <= 21\r\nmaxexp(x) = 1024 for x float bin(p), 21 < p <= 53\r\nmaxexp(x) = 16384 for x float bin(p), 53 < p\r\nmaxexp(x) = 128 for x float dec(p), p <= 6\r\nmaxexp(x) = 1024 for x float dec(p), 6 < p <= 16\r\nmaxexp(x) = 16384 for x float dec(p), 16 < p\r\nExample (z/OS IEEE Decimal Floating Point Values)\r\nmaxexp(x) = 97 for x float dec(p), p <= 7\r\nmaxexp(x) = 385 for x float dec(p), 7 < p <= 16\r\nmaxexp(x) = 6145 for x float dec(p), 16 < p
MAXLENGTH = MAXLENGTH returns the maximum length of a string.$MAXLENGTH(x)$x Expression. x must have a computational type and should have a string type.\r\nIf not, it is converted to character.\r\nExample\r\ndcl x char(20);\r\ndcl y char(20) varying;\r\nx, y = '';\r\nx = copy( '*', length(x) ); /* fills x with '*' */\r\ny = copy( '*', length(y) ); /* leaves y unchanged */\r\nx = copy( '-', maxlength(x) ); /* fills x with '-' */\r\ny = copy( '-', maxlength(y) ); /* fills y with '-' */\r\nNote that the first assignment to y leaves it unchanged because length(y) will return\r\nzero when it is used in the code snippet above (since y is VARYING and was\r\npreviously set to '').\r\nHowever, the second assignment to y fills it with 20 ? signs because maxlength(y)\r\nwill return 20 (the declared length of y).
MEMCONVERT = MEMCONVERT converts the data in a source buffer from the specified source\r\ncodepage to a a specified target codepage, stores the result in a target buffer, and\r\nreturns an unscaled REAL FIXED BINARY value specifying the number of bytes\r\nwritten to the target buffer.$MEMCONVERT ( p , n , c , q , m , d )$p Address of the target buffer.\r\nn Length of the target buffer.\r\nc Target code page.\r\nq Address of the source buffer.\r\nm Length of the source buffer.\r\nd Source code page.\r\nThe buffer lengths must have computational type and will be converted to FIXED\r\nBINARY(31,0).\r\nThe buffer lengths must be nonnegative.\r\nIf either buffer length is zero, the result is zero.\r\nThe code page must have computational type and will be converted to FIXED\r\nBINARY(31,0).\r\nThe code pages must specify valid, supported code pages.
MEMCU12 = MEMCU12 converts the data in a source buffer from UTF-8 to UTF-16, stores the\r\nresult in a target buffer, and returns an unscaled REAL FIXED BINARY value\r\nspecifying the number of bytes written to the target buffer.$MEMCU12 ( p , n , q , m )$p Address of the target buffer.\r\nn Length of the target buffer.\r\nq Address of the source buffer.\r\nm Length of the source buffer.\r\nThe buffer lengths must have computational type and will be converted to FIXED\r\nBINARY(31,0).\r\nThe buffer lengths must be nonnegative.\r\nIf the target buffer is too small or if the source UTF-8 is invalid, a value of -1 is\r\nreturned.\r\nOn z/OS, this built-in function requires an ARCH level of 7 or higher.
MEMCU14 = MEMCU14 converts the data in a source buffer from UTF-8 to UTF-32, stores the\r\nresult in a target buffer, and returns an unscaled REAL FIXED BINARY value\r\nspecifying the number of bytes written to the target buffer.$MEMCU14 ( p , n , q , m )$p Address of the target buffer.\r\nn Length of the target buffer.\r\nq Address of the source buffer.\r\nm Length of the source buffer.\r\nThe buffer lengths must have computational type and will be converted to FIXED\r\nBINARY(31,0).\r\nThe buffer lengths must be nonnegative.\r\nIf the target buffer is too small or if the source UTF-8 is invalid, a value of -1 is\r\nreturned.\r\nOn z/OS, this built-in function requires an ARCH level of 7 or higher.
MEMCU21 = MEMCU21 converts the data in a source buffer from UTF-16 to UTF-8, stores the\r\nresult in a target buffer, and returns an unscaled REAL FIXED BINARY value\r\nspecifying the number of bytes written to the target buffer.$MEMCU21 ( p , n , q , m )$p Address of the target buffer.\r\nn Length of the target buffer.\r\nq Address of the source buffer.\r\nm Length of the source buffer.\r\nThe buffer lengths must have computational type and will be converted to FIXED\r\nBINARY(31,0).\r\nThe buffer lengths must be nonnegative.\r\nIf the target buffer is too small or if the source UTF-16 is invalid, a value of -1 is\r\nreturned.\r\nOn z/OS, this built-in function requires an ARCH level of 7 or higher.
MEMCU24 = MEMCU24 converts the data in a source buffer from UTF-16 to UTF-32, stores the\r\nresult in a target buffer, and returns an unscaled REAL FIXED BINARY value\r\nspecifying the number of bytes written to the target buffer.$MEMCU24 ( p , n , q , m )$p Address of the target buffer.\r\nn Length of the target buffer.\r\nq Address of the source buffer.\r\nm Length of the source buffer.\r\nThe buffer lengths must have computational type and will be converted to FIXED\r\nBINARY(31,0).\r\nThe buffer lengths must be nonnegative.\r\nIf the target buffer is too small or if the source UTF-16 is invalid, a value of -1 is\r\nreturned.\r\nOn z/OS, this built-in function requires an ARCH level of 7 or higher.
MEMCU41 = MEMCU41 converts the data in a source buffer from UTF-32 to UTF-8, stores the\r\nresult in a target buffer, and returns an unscaled REAL FIXED BINARY value\r\nspecifying the number of bytes written to the target buffer.$MEMCU41 ( p , n , q , m )$p Address of the target buffer.\r\nn Length of the target buffer.\r\nq Address of the source buffer.\r\nm Length of the source buffer.\r\nThe buffer lengths must have computational type and will be converted to FIXED\r\nBINARY(31,0).\r\nThe buffer lengths must be nonnegative.\r\nIf the target buffer is too small or if the source UTF-32 is invalid, a value of -1 is\r\nreturned.\r\nOn z/OS, this built-in function requires an ARCH level of 7 or higher.
MEMCU42 = MEMCU42 converts the data in a source buffer from UTF-32 to UTF-16, stores the\r\nresult in a target buffer, and returns an unscaled REAL FIXED BINARY value\r\nspecifying the number of bytes written to the target buffer.$MEMCU42 ( p , n , q , m )$p Address of the target buffer.\r\nn Length of the target buffer.\r\nq Address of the source buffer.\r\nm Length of the source buffer.\r\nThe buffer lengths must have computational type and will be converted to FIXED\r\nBINARY(31,0).\r\nThe buffer lengths must be nonnegative.\r\nIf the target buffer is too small or if the source UTF-32 is invalid, a value of -1 is\r\nreturned.\r\nOn z/OS, this built-in function requires an ARCH level of 7 or higher.
MEMINDEX = MEMINDEX returns an unscaled REAL FIXED BINARY value indicating the\r\nstarting position within a buffer of a specified substring.\r\nWith 3 arguments, the function's syntax is :$MEMINDEX ( p , n , x )MEMINDEX ( p , n , q , m )$p Address of buffer to be searched\r\nn Length of buffer to be searched.\r\nx String-expression to use as the target of the search.\r\nWith 4 arguments, the function's syntax is\r\np Address of first buffer to be searched.\r\nn Length of first buffer to be searched.\r\nq Address of second buffer to use as the target of the search.\r\nm Length of second buffer to use as the target of the search.\r\nThe buffer lengths must have a computational type and will be converted to\r\nFIXED BINARY(31,0).\r\nThe buffer lengths must be nonnegative\r\nWith 3 arguments, the target string-expression must have type CHARACTER\r\n(including PICTURE), GRAPHIC or WIDECHAR. The buffer length is interpreted\r\nas the number of units of that string type.\r\nWith 4 arguments, the buffer lengths specify a number of bytes and the search\r\nperformed is a character search.\r\nFor a VARYING or VARYINGZ string X and string Y, the function MEMINDEX(\r\nADDRDATA(X), LENGTH(X), Y ) will return the same value as INDEX( X, Y ).\r\nExample\r\ndcl cb(128*1024) char(1);\r\ndcl wb(128*1024) widechar(1);\r\ndcl pos fixed bin(31);\r\n/* 128K bytes searched for the character string 'test' */\r\npos = memindex( addr(cb), stg(cb), 'test' );\r\n/* 256K bytes searched for the string 'test' as widechar */\r\npos = memindex( addr(wb), stg(wb), wchar('<') );
MEMSEARCH = MEMSEARCH returns an unscaled REAL FIXED BINARY value specifying the first\r\nposition (from the left) in a buffer at which any character, graphic or widechar in a\r\ngiven string appears.$MEMSEACRH ( p , n , x )$p Address of buffer to be searched.\r\nn Length of buffer to be searched.\r\nx String-expression.\r\nThe buffer length must have a computational type and will be converted to FIXED\r\nBINARY(31,0).\r\nThe buffer length must be nonnegative.\r\nThe string-expression x must have type CHARACTER (including PICTURE),\r\nGRAPHIC or WIDECHAR. The buffer length is interpreted as the number of units\r\nof that string type.\r\nThe address p and the length n specify the "string" in which to search for any\r\ncharacter, graphic or widechar that appears in x.\r\nIf either the buffer length n is zero or x is the null string, the result is zero.\r\nIf x does not occur in the buffer, the result is zero.\r\nExample\r\ndcl cb(128*1024) char(1);\r\ndcl wb(128*1024) widechar(1);\r\ndcl pos fixed bin(31);\r\n/* 128K bytes searched from the left for a numeric */\r\npos = memsearch( addr(cb), stg(cb), '012345789' );\r\n/* 256K bytes searched from the left for a widechar '0' or '1' */\r\npos = memsearch( addr(wb), stg(wb), '0030_0031'wx );
MEMSEARCHR = MEMSEARCHR returns an unscaled REAL FIXED BINARY value specifying the\r\nfirst position (from the right) in a buffer at which any character, graphic or\r\nwidechar in a given string appears$MEMSEACRHR ( p , n , x )$p Address of buffer to be searched.\r\nn Length of buffer to be searched.\r\nx String-expression.\r\nThe buffer length must have a computational type and will be converted to FIXED\r\nBINARY(31,0).\r\nThe buffer length must be nonnegative.\r\nThe string-expression x must have type CHARACTER (including PICTURE),\r\nGRAPHIC or WIDECHAR. The buffer length is interpreted as the number of units\r\nof that string type.\r\nThe address p and the length n specify the "string" in which to search for any\r\ncharacter, graphic or widechar that appears in x.\r\nIf either the buffer length n is zero or x is the null string, the result is zero.\r\nIf x does not occur in the buffer, the result is zero.\r\nExample\r\ndcl cb(128*1024) char(1);\r\ndcl wb(128*1024) widechar(1);\r\ndcl pos fixed bin(31);\r\n/* 128K bytes searched from the right for a numeric */\r\npos = memsearchr( addr(cb), stg(cb), '012345789' );\r\n/* 256K bytes searched from the right for a widechar '0' or '1' */\r\npos = memsearchr( addr(wb), stg(wb), '0030_0031'wx );
MEMVERIFY = MEMVERIFY returns an unscaled REAL FIXED BINARY value specifying the\r\nposition in a buffer of the first (from the left) character, graphic or widechar that is\r\nnot in a specified string.$MEMVERIFY ( p , n , x )$p Address of buffer to be searched.\r\nn Length of buffer to be searched.\r\nx String-expression.\r\nThe buffer length must have a computational type and will be converted to FIXED\r\nBINARY(31,0).\r\nThe buffer length must be nonnegative.\r\nThe string-expression x must have type CHARACTER (including PICTURE),\r\nGRAPHIC or WIDECHAR. The buffer length is interpreted as the number of units\r\nof that string type.\r\nThe address p and the length n specify the "string" in which to search for any\r\ncharacter, graphic or widechar that does not appear in x.\r\nIf either the buffer length n is zero or x is the null string, the result is zero.\r\nIf all the characters, graphics or widechars in the buffer do appear in x, the result\r\nis zero.\r\nExample\r\ndcl cb(128*1024) char(1);\r\ndcl wb(128*1024) widechar(1);\r\ndcl pos fixed bin(31);\r\n/* 128K bytes searched from the left for a non-numeric */\r\npos = memverify( addr(cb), stg(cb), '012345789' );\r\n/* 256K bytes searched from the left for the a non-blank widechar */\r\npos = memverify( addr(wb), stg(wb), '0020'wx );
MEMVERIFYR = MEMVERIFYR returns an unscaled REAL FIXED BINARY value specifying the\r\nposition in a buffer of the first (from the right) character, graphic or widechar that\r\nis not in a specified string.$MEMVERIFYR ( p , n , x )$p Address of buffer to be searched.\r\nn Length of buffer to be searched.\r\nx String-expression.\r\nThe buffer length must have a computational type and will be converted to FIXED\r\nBINARY(31,0).\r\nThe buffer length must be nonnegative.\r\nThe string-expression x must have type CHARACTER (including PICTURE),\r\nGRAPHIC or WIDECHAR. The buffer length is interpreted as the number of units\r\nof that string type.\r\nThe address p and the length n specify the "string" in which to search for any\r\ncharacter, graphic or widechar that does not appear in x.\r\nIf either the buffer length n is zero or x is the null string, the result is zero.\r\nIf all the characters, graphics or widechars in the buffer do appear in x, the result\r\nis zero.\r\nExample\r\ndcl cb(128*1024) char(1);\r\ndcl wb(128*1024) widechar(1);\r\ndcl pos fixed bin(31);\r\n/* 128K bytes searched from the right for a non-numeric */\r\npos = memverify( addr(cb), stg(cb), '012345789' );\r\n/* 256K bytes searched from the right for the a non-blank widechar */\r\npos = memverify( addr(wb), stg(wb), '0020'wx );
MIN = MIN returns the smallest value from a set of one or more expressions.$MIN( x, y )$x and y\r\nExpressions.\r\nAll the arguments must be real. The result is real with the common base and scale\r\nof the arguments.\r\nThe precision of the result is the same as that described in ?MAX? on page 529.\r\nThe maximum number of arguments allowed is 64.
MINEXP = MINEXP returns a FIXED BINARY(31,0) value that is the minimum value that\r\nEXPONENT(x) could assume.$MINEXP(x)$x Expression. x must have the REAL and FLOAT attributes.\r\nMINEXP(x) is a constant and can be used in restricted expressions.\r\nExample (Intel Values)\r\nminexp(x) = -00125 for x float bin(p), p <= 21\r\nminexp(x) = -01021 for x float bin(p), 21 < p <= 53\r\nminexp(x) = -16831 for x float bin(p), 53 < p\r\nminexp(x) = -00125 for x float dec(p), p <= 6\r\nminexp(x) = -01021 for x float dec(p), 6 < p <= 16\r\nminexp(x) = -16831 for x float dec(p), 16 < p\r\nExample (AIX Values)\r\nminexp(x) = -0125 for x float bin(p), p <= 21\r\nminexp(x) = -1021 for x float bin(p), 21 < p <= 53\r\nminexp(x) = -0968 for x float bin(p), 53 < p\r\nminexp(x) = -0125 for x float dec(p), p <= 6\r\nminexp(x) = -1021 for x float dec(p), 6 < p <= 16\r\nminexp(x) = -0968 for x float dec(p), 16 < p\r\nExample (z/OS Hexadecimal Values)\r\nminexp(x) = -64 for x float bin(p), p <= 21\r\nminexp(x) = -64 for x float bin(p), 21 < p <= 53\r\nminexp(x) = -50 for x float bin(p), 53 < p\r\nminexp(x) = -64 for x float dec(p), p <= 6\r\nminexp(x) = -64 for x float dec(p), 6 < p <= 16\r\nminexp(x) = -50 for x float dec(p), 16 < p\r\nExample (z/OS IEEE Binary Floating Point Values)\r\nminexp(x) = -125 for x float bin(p), p <= 21\r\nminexp(x) = -1021 for x float bin(p), 21 < p <= 53\r\nminexp(x) = -16381 for x float bin(p), 53 < p\r\nminexp(x) = -125 for x float dec(p), p <= 6\r\nminexp(x) = -1021 for x float dec(p), 6 < p <= 16\r\nminexp(x) = -16381 for x float dec(p), 16 < p\r\nExample (z/OS IEEE Decimal Floating Point Values)\r\nminexp(x) = -94 for x float dec(p), p <= 7\r\nminexp(x) = -382 for x float dec(p), 7 < p <= 16\r\nminexp(x) = -6142 for x float dec(p), 16 < p
MOD = MOD returns the smallest nonnegative value, R, such that:\r\n(x - R)/y = n\r\nIn this example, the value for n is an integer value. That is, R is the smallest\r\nnonnegative value that must be subtracted from x to make it divisible by y.$MOD(x,y)$x Real expression.\r\ny Real expression. If y = 0, the ZERODIVIDE condition is raised.\r\nThe result, R, is real with the common base and scale of the arguments. If the\r\nresult is floating-point, the precision is the greater of those of x and y. If the result\r\nis fixed-point, the precision is given by the following:\r\n(min(n,p2-q2+max(q1,q2)),max(q1,q2))\r\nIn this example, (p1,q1) and (p2,q2) are the precisions of x and y, respectively, and\r\nn is N for FIXED DECIMAL or M for FIXED BINARY.\r\nIf x and y are fixed-point with different scaling factors, the argument with the\r\nsmaller scaling factor is converted to the larger scaling factor before R is calculated.\r\nIf the conversion fails, the result is unpredictable.\r\nIf the result has the attributes FIXED BIN and one or more of the operands has the\r\nattributes UNSIGNED FIXED BIN, the result has the SIGNED attribute unless both\r\nof the following conditions are true:\r\nv All of the operands are UNSIGNED FIXED BIN.\r\nv The RULES(ANS) compiler option is in effect.\r\nIf any of the conditions above is not true, each UNSIGNED operand is converted\r\nto SIGNED. If the operand is too large, the conversion would:\r\nv Raise the SIZE condition if SIZE is enabled.\r\nv Produce a negative value if SIZE is not enabled.\r\nThe following example contrasts the MOD and REM built-in functions.\r\nFor information on the REM built-in function, see ?REM? on page 629.\r\nExample\r\nrem( +10, +8 ) = 2\r\nmod( +10, +8 ) = 2\r\nrem( +10, -8 ) = 2\r\nmod( +10, -8 ) = 2\r\nrem( -10, +8 ) = -2\r\nmod( -10, +8 ) = 6\r\nrem( -10, -8 ) = -2\r\nmod( -10, -8 ) = 6
MPSTR = MPSTR truncates a string at a logical boundary and returns a mixed character\r\nstring. It does not truncate a double-byte character between bytes. The length of\r\nthe returned string is equal to the length of the expression x, or to the value\r\nspecified by y. The processing of the string is determined by the rules selected by\r\nthe expression r, as described below.$MPSTR(x,r ),y$x Expression that yields the character string result. The value of x is converted to\r\ncharacter if necessary.\r\nr Expression that yields a character result. The expression cannot be GRAPHIC\r\nand is converted to character if necessary.\r\nThe expression r specifies the rules to be used for processing the string. The\r\ncharacters that can be used in r and the rules for them are as follows:\r\nV or v\r\nValidates the mixed string x and returns a mixed string.\r\nS or s\r\nRemoves any null DBCS strings, creates a new string, and returns a mixed\r\nstring.\r\nIf both V and S are specified, V takes precedence over S, regardless of the\r\norder in which they were specified.\r\nIf S is specified without V, the string x is assumed to be a valid string. If the\r\nstring is not valid, undefined results occur.\r\nNote: The parameter r is ignored on Intel and AIX.\r\ny Expression. If necessary, y is converted to a real fixed-point binary value. If y is\r\nomitted, the length is determined by the rules for type conversion. The value\r\nof y cannot be negative. If y = 0, the result is the null character string. If y is\r\ngreater than the length needed to contain x, the result is padded with blanks. If\r\ny is less than the length needed to contain x, the result is truncated by\r\ndiscarding excess characters from the right (if they are SBCS characters), or by\r\ndiscarding as many DBCS characters (2-byte pairs) as needed.
MULTIPLY = MULTIPLY returns the product of x and y, with a precision specified by p and q.\r\nThe base, scale, and mode of the result are determined by the rules for expression\r\nevaluation unless overruled by the PRECTYPE compiler option.$MULTIPLY(x,y,p ),q$x and y\r\nExpressions.\r\np Restricted expression that specifies the number of digits to be maintained\r\nthroughout the operation.\r\nq Restricted expression that specifies the scaling factor of the result. For a\r\nfixed-point result, if q is omitted, a scaling factor of zero is assumed. For a\r\nfloating-point result, q must be omitted.\r\nNote that when applied to FIXED DECIMAL, then if the mathematical result is too\r\nbig for the specified precision p but less than the maximum implementation value,\r\nv if SIZE is disabled, the FIXEDOVERFLOW condition will not be raised and the\r\nresult will be truncated\r\nv if SIZE is enabled, the SIZE condition will be raised\r\nNote that the above text is false when the non-default compiler option\r\nDECIMAL(FOFLONMULT) is in effect. In that case, FIXEDOVERFLOW will be\r\nraised if SIZE is disabled (and the result is too big).
NULL = NULL returns the null pointer value. The null pointer value does not identify any\r\ngeneration of a variable. The null pointer value can be assigned to and compared\r\nwith handles. The null pointer value can be converted to OFFSET by assignment of\r\nthe built-in function value to an offset variable.$NULL()$null
OFFSET = OFFSET returns an offset value derived from a pointer reference x and relative to\r\nan area y. If x is the null pointer value, the null offset value is returned.$OFFSET ( x , y )$x Pointer reference. It must identify a generation of a based variable within the\r\narea y, or be the null pointer value.\r\ny Area reference.\r\nIf x is an element reference, y must be an element variable.
OFFSETADD = OFFSETADD returns the sum of the arguments.$OFFSETADD(x,y)$x Expression. x must be specified as OFFSET.\r\ny Expression. y must have a computational type and is converted to FIXED\r\nBINARY(31,0).
OFFSETDIFF = OFFSETDIFF returns a FIXED BINARY(31,0) value that is the arithmetic difference\r\nbetween the arguments.$OFFSETDIFF(x,y)$x and y\r\nExpressions. Both must be specified as OFFSET.
OFFSETSUBTRACT = OFFSETSUBTRACT is equivalent to OFFSETADD(x,-y).$OFFSETSUBTRACT(x,y)$x Expressions. x must be specified as OFFSET.\r\ny Expression. y must have a computational type and is converted to FIXED\r\nBINARY(31,0).
OFFSETVALUE = OFFSETVALUE returns an offset value that is the converted value of x.$OFFSETVALUE(x)$x Expression. x must have a computational type and is converted to FIXED\r\nBINARY(31,0).
OMITTED = OMITTED returns a BIT(1) value that is '1'B if the parameter named x was omitted\r\nin the invocation to its containing procedure.$OMITTED(x)$x Level-1 unsubscripted parameter with the BYADDR attribute.\r\nNote: This argument must be declared as OPTIONAL in the corresponding\r\nENTRY declaration in the calling code.
ONAREA = ONAREA returns a character string whose value is the name of the AREA\r\nreference for which an AREA condition is raised. If the reference includes DBCS\r\nnames, the string returned is a mixed character string. It is in context in an\r\nON-unit (or any of its dynamic descendants) for the AREA condition, or for the\r\nERROR or FINISH condition raised as the implicit action for an AREA condition.$ONAREA()$If the ONAREA built-in function is used out of context, a null string is returned.\r\nIf the AREA reference is excessively long or complicated, a null string is returned.
ONCHAR = ONCHAR returns a character(1) string containing the character that caused the\r\nCONVERSION condition to be raised. It is in context in an ON-unit (or any of its\r\ndynamic descendants) for the CONVERSION condition or for the ERROR or\r\nFINISH condition raised as the implicit action for the CONVERSION condition.$ONCHAR()$If the ONCHAR built-in function is used out of context, a blank is returned.\r\nONCHAR pseudovariable\r\nThe ONCHAR pseudovariable sets the current value of the ONCHAR built-in\r\nfunction. The element value assigned to the pseudovariable is converted to a\r\ncharacter value of length 1. The new character is used when the conversion is\r\nattempted again. (See conversions in Chapter 5, ?Data conversion,? on page 81.)\r\nThe pseudovariable must not be used out of context.\r\nONCHAR pseudovariable
ONCODE = The ONCODE built-in function provides a fixed-point binary value that depends\r\non the cause of the last condition. ONCODE can be used to distinguish between\r\nthe various circumstances that raise a particular condition?for instance, the\r\nERROR condition. For codes corresponding to the conditions and errors detected,\r\nrefer to the specific condition.\r\nONCODE returns a real fixed-point binary value that is the condition code. It is in\r\ncontext in any ON-unit or its dynamic descendant. All condition codes are defined\r\nin Messages and Codes.$ONCODE()$If ONCODE is used out of context, zero is returned.
ONCONDCOND = ONCONDCOND returns a nonvarying character string whose value is the name of\r\nthe condition for which a CONDITION condition is raised. If the name is a DBCS\r\nname, it will be returned as a mixed character string. It is in context in the\r\nfollowing circumstances:\r\nv In a CONDITION ON-unit, or any of its dynamic descendants\r\nv In an ANYCONDITION ON-unit that traps a CONDITION condition, or any\r\ndynamic descendants of such an ON-unit.$ONCONDCOND()$If ONCONDCOND is used out of context, a null string is returned.
ONCONDID = ONCONDID (short for ON-condition identifier) returns a FIXED BINARY(31,0)\r\nvalue that identifies the condition being handled by an ON-unit. It is in context in\r\nany ON-unit or one of its dynamic descendants.$ONCONDID()$The values returned by ONCONDID are given in the following DECLARE\r\nstatement:\r\ndeclare ( condid_area value(1),\r\ncondid_attention value(2),\r\ncondid_condition value(3),\r\ncondid_conversion value(4),\r\ncondid_endfile value(5),\r\ncondid_endpage value(6),\r\ncondid_error value(7),\r\ncondid_finish value(8),\r\ncondid_fixedoverflow value(9),\r\ncondid_invalidop value(10),\r\ncondid_key value(11),\r\ncondid_name value(12),\r\ncondid_overflow value(13),\r\ncondid_record value(14),\r\ncondid_size value(15),\r\ncondid_storage value(16),\r\ncondid_stringrange value(17),\r\ncondid_stringsize value(18),\r\ncondid_subscriptrange value(19),\r\ncondid_transmit value(20),\r\ncondid_undefinedfile value(21),\r\ncondid_underflow value(22),\r\ncondid_zerodivide value(23)\r\n) fixed bin(31);\r\nIf ONCONDID is used out of context, a value of zero is returned.
ONCOUNT = ONCOUNT returns an unscaled REAL FIXED BINARY value specifying the\r\nnumber of conditions that remain to be handled when an ON-unit is entered. (See\r\n?Multiple conditions? on page 358.) It is in context in any ON-unit, or any\r\ndynamic descendant of an ON-unit.$ONCOUNT()$If ONCOUNT is used out of context, zero is returned.\r\nThe BIFPREC compiler option determines the precision of the result returned.
ONFILE = ONFILE returns a character string whose value is the name of the file for which an\r\ninput or output condition is raised. If the name is a DBCS name, it is returned as a\r\nmixed character string. It is in context in an ON-unit (or any of its dynamic\r\ndescendants) for an input or output condition, or for the ERROR or FINISH\r\ncondition raised as the implicit action for an input or output condition.$ONFILE()$If ONFILE is used out of context, a null string is returned.
ONGSOURCE = ONGSOURCE returns a graphic string containing the DBCS character that caused\r\nthe CONVERSION condition to be raised. It is in context in an ON-unit (or any of\r\nits dynamic descendants) for the CONVERSION condition or for the ERROR or\r\nFINISH condition raised as the implicit action for a CONVERSION condition.$ONGSOURCE()$If the ONGSOURCE built-in function is used out of context, a null GRAPHIC\r\nstring is returned.\r\nONGSOURCE pseudovariable\r\nThe ONGSOURCE pseudovariable sets the current value of the ONGSOURCE\r\nbuilt-in function. The element value assigned to the pseudovariable is converted\r\ngraphic. The string is used when the conversion is attempted again.\r\nThe pseudovariable must not be used out of context.\r\nONGSOURCE pseudovariable
ONKEY = ONKEY returns a character string whose value is the key of the record that raised\r\nan input/output condition. For indexed files, if the key is GRAPHIC, the string is\r\nreturned as a mixed character string. ONKEY is in context for the following:\r\nv An ON-unit, or any of its dynamic descendants\r\nv Any input/output condition, except ENDFILE\r\nv The ERROR or FINISH condition raised as implicit action for an input/output\r\ncondition.\r\nONKEY is always set for operations on a KEYED file, even if the statement that\r\nraised the condition does not specified the KEY, KEYTO, or KEYFROM options.$ONKEY()$The result of specifying ONKEY is:\r\nv For any input/output condition (other than ENDFILE), or for the ERROR or\r\nFINISH condition raised as implicit action for these conditions, the result is the\r\nvalue of the recorded key from the I/O statement causing the error.\r\nv For relative data sets, the result is a character string representation of the relative\r\nrecord number. If the key was incorrectly specified, the result is the last 8\r\ncharacters of the source key. If the source key is less than 8 characters, it is\r\npadded on the right with blanks to make it 8 characters. If the key was correctly\r\nspecified, the character string consists of the relative record number in character\r\nform padded on the left with blanks, if necessary.\r\nv For a REWRITE statement that attempts to write an updated record on to an\r\nindexed data set when the key of the updated record differs from that of the\r\ninput record, the result is the value of the embedded key of the input record.\r\nIf ONKEY is used out of context, a null string is returned.
ONLINE = ONLINE returns a FIXED BIN(31) value which is the line number in the source in\r\nwhich a condition was raised.$ONLINE()$The source program must have been compiled with the GONUMBER option, and\r\non Windows it must also have been linked with the /debug option.\r\nIf ONLINE is used out of context, a value of zero is returned.
ONLOC = ONLOC returns a character string whose value is the name of the entry-point used\r\nfor the current invocation of the procedure in which a condition was raised.\r\nONLOC always returns the leftmost name of a multiple label specification,\r\nregardless of which name appears in the CALL or GOTO statement.\r\nIf the name is a DBCS name, it is returned as a mixed-character string. It is in\r\ncontext in any ON-unit, or in any of its dynamic descendants.$ONLOC()$If ONLOC is used out of context, a null string is returned.
ONOFFSET = ONOFFSET returns a FIXED BIN(31) value which is the offset from the start of the\r\nuser procedure (or BEGIN block) in which a condition was raised.$ONOFFSET()$If ONOFFSET is used out of context, a value of zero is returned.
ONSOURCE = ONSOURCE returns a character string whose value is the contents of the field that\r\nwas being processed when the CONVERSION condition was raised. It is in context\r\nin an ON-unit (or any of its dynamic descendants) for the CONVERSION\r\ncondition or for the ERROR or FINISH condition raised as the implicit action for a\r\nCONVERSION condition.$ONSOURCE()$If ONSOURCE is used out of context, a null string is returned.\r\nIf the source in a failed conversion is a COMPLEX value, then ONSOURCE() will\r\nshow only the REAL or IMAG half of that value\r\nONSOURCE pseudovariable\r\nThe ONSOURCE pseudovariable sets the current value of the ONSOURCE built-in\r\nfunction. The element value assigned to the pseudovariable is converted to a\r\ncharacter string and, if necessary, is padded on the right with blanks or truncated\r\nto match the length of the field that raised the CONVERSION condition. The string\r\nis used when the conversion is attempted again.\r\nWhen conversion is retried, the string assigned to the pseudovariable is processed\r\nas a single data item. For this reason, the error correction process must not assign a\r\nstring containing more than one data item when the conversion occurs during the\r\nexecution of a GET LIST or GET DATA statement. The presence of blanks or\r\ncommas in the string could raise CONVERSION again.\r\nThe pseudovariable must not be used out of context.\r\nIf ONSOURCE is not a binary constant, then the ONSOURCE pseudovariable must\r\nnot set it to one. For example, if ONSOURCE() is 'ERR', you must must not set\r\nONSOURCE() to '0'B.\r\nONSOURCE pseudovariable
ONSUBCODE = ONSUBCODE returns a FIXED BINARY(31,0) value that gives more information\r\nabout an I/O error that occurred. This corresponds to the SUBCODE1 values\r\ndocumented for messages IBM0236I and IBM0265I. These values are defined in\r\nMessages and Codes.$ONSUBCODE()$null
ONWCHAR = ONWCHAR returns a widechar(1) string containing the widechar that caused the\r\nCONVERSION condition to be raised. It is in context in an ON-unit (or any of its\r\ndynamic descendants) for the CONVERSION condition or for the ERROR or\r\nFINISH condition raised as the implicit action for the CONVERSION condition.$ONWCHAR()$If the ONWCHAR built-in function is used out of context, a widechar blank is\r\nreturned.\r\nONWCHAR pseudovariable\r\nThe ONWCHAR pseudovariable sets the current value of the ONWCHAR built-in\r\nfunction. The element value assigned to the pseudovariable is converted to a\r\nwidechar value of length 1. The new widechar is used when the conversion is\r\nattempted again. (See conversions in Chapter 5, ?Data conversion,? on page 81.)\r\nThe pseudovariable must not be used out of context.\r\nONWCHAR pseudovariable
ONWSOURCE = ONWSOURCE returns a widechar string whose value is the contents of the field\r\nthat was being processed when the CONVERSION condition was raised. It is in\r\ncontext in an ON-unit (or any of its dynamic descendants) for the CONVERSION\r\ncondition or for the ERROR or FINISH condition raised as the implicit action for a\r\nCONVERSION condition.$ONWSOURCE()$If ONWSOURCE is used out of context, a null string is returned.\r\nONWSOURCE pseudovariable\r\nThe ONWSOURCE pseudovariable sets the current value of the ONWSOURCE\r\nbuilt-in function. The element value assigned to the pseudovariable is converted to\r\na widechar string and, if necessary, is padded on the right with widechar blanks or\r\ntruncated to match the length of the field that raised the CONVERSION condition.\r\nThe string is used when the conversion is attempted again.\r\nWhen conversion is retried, the string assigned to the pseudovariable is processed\r\nas a single data item. For this reason, the error correction process must not assign a\r\nstring containing more than one data item when the conversion occurs during the\r\nexecution of a GET LIST or GET DATA statement. The presence of blanks or\r\ncommas in the string could raise CONVERSION again.\r\nThe pseudovariable must not be used out of context.\r\nONWSOURCE pseudovariable
ORDINALNAME = ORDINALNAME returns a nonvarying character string that is the member of the\r\nset associated with the ordinal x.$ORDINALNAME(x)$x Reference. It must have ordinal type.\r\nORDINALs cannot be used in computational expressions and cannot be converted\r\nto character, but ORDINALNAME provides a way to obtain a displayable value for\r\nan ORDINAL and can be very useful in debugging.
ORDINALPRED = ORDINALPRED returns an ordinal that is the next lower value that the ordinal x\r\ncould assume.$ORDINALPRED(x)$x Reference. It must have ordinal type.\r\nThe returned ordinal has the same type as ordinal x.
ORDINALSUCC = ORDINALSUCC returns an ordinal that is the next higher value the ordinal x\r\ncould assume.$ORDINALSUCC(x)$x Reference. It must have ordinal type.\r\nThe returned ordinal has the same type as ordinal x.
PACKAGENAME = PACKAGENAME returns a nonvarying character string containing the name of the\r\npackage in which it is invoked. If there is no package in the current compilation\r\nunit, PACKAGENAME returns the name of the outermost procedure.$PACKAGENAME()$null
PAGENO = PAGENO returns an unscaled REAL FIXED BINARY31 value that is the current\r\npage number associated with file x.$PAGENO(x)$x File reference. The file must be open and have the PRINT attribute.\r\nIf the file is not a PRINT file, the ERROR condition is raised.\r\nThe BIFPREC compiler option determines the precision of the result returned.
PICSPEC = The PICSPEC built-in function casts data from CHARACTER to PICTURE type.$PICSPEC ( x , y )$x Expression.\r\ny Picture specification.\r\nThe expression x must be CHARACTER NONVARYING with a length known at\r\ncompile time.\r\ny must be a character literal that specifies a valid PICTURE with an external\r\nrepresentation that has the same length as the first argument.\r\nThe result has the PICTURE type specified by the second argument.\r\nUnlike the EDIT built-in function, no conversion is done and no checks are made\r\nto see if the first argument holds data valid for the picture.\r\nLike the UNSPEC built-in function, only the "type" of the data is changed.\r\nSo, for example given PICSPEC(x,'(5)9'), x must be CHAR(5) (since while the\r\npicture specification '(5)9' was 4 characters in length, its external representation\r\nrequires 5 characters), but x will not be checked to see if it actually contains 5\r\nnumeric digits.\r\nA statement of the N = N + PICSPEC(X,'(5)9') will not cause x to be converted\r\nfrom CHAR to PIC'(5)9', a conversion that would require a library call, but will\r\ncause the contents of x to be treated as if it were declared as PIC'(5)9'.
PLACES = PLACES returns a FIXED BINARY(31,0) value that is the model-precision used to\r\nrepresent the floating-point expression x.$PLACES(x)$x Expression. x must be declared REAL FLOAT.\r\nPLACES(x) is a constant and can be used in restricted expressions.\r\nExample (Intel Values)\r\nplaces(x) = 24 for x float bin(p), p <= 21\r\nplaces(x) = 53 for x float bin(p), 21 < p <= 53\r\nplaces(x) = 64 for x float bin(p), 53 < p\r\nplaces(x) = 24 for x float dec(p), p <= 6\r\nplaces(x) = 53 for x float dec(p), 6 < p <= 16\r\nplaces(x) = 64 for x float dec(p), 16 < p\r\nExample (AIX Values)\r\nplaces(x) = 024 for x float bin(p), p <= 21\r\nplaces(x) = 053 for x float bin(p), 21 < p <= 53\r\nplaces(x) = 106 for x float bin(p), 53 < p\r\nplaces(x) = 024 for x float dec(p), p <= 6\r\nplaces(x) = 053 for x float dec(p), 6 < p <= 16\r\nplaces(x) = 106 for x float dec(p), 16 < p\r\nExample (z/OS Hexadecimal Values)\r\nplaces(x) = 6 for x float bin(p), p <= 21\r\nplaces(x) = 14 for x float bin(p), 21 < p <= 53\r\nplaces(x) = 28 for x float bin(p), 53 < p\r\nplaces(x) = 6 for x float dec(p), p <= 6\r\nplaces(x) = 14 for x float dec(p), 6 < p <= 16\r\nplaces(x) = 28 for x float dec(p), 16 < p\r\nExample (z/OS IEEE Binary Floating Point Values)\r\nplaces(x) = 24 for x float bin(p), p <= 21\r\nplaces(x) = 53 for x float bin(p), 21 < p <= 53\r\nplaces(x) = 113 for x float bin(p), 53 < p\r\nplaces(x) = 24 for x float dec(p), p <= 6\r\nplaces(x) = 53 for x float dec(p), 6 < p <= 16\r\nplaces(x) = 113 for x float dec(p), 16 < p\r\nExample (z/OS IEEE Decimal Floating Point Values)\r\nplaces(x) = 7 for x float dec(p), p <= 7\r\nplaces(x) = 16 for x float dec(p), 7 < p <= 16\r\nplaces(x) = 34 for x float dec(p), 16 < p
PLIASCII = PLIASCII converts Z storage units (bytes) at location y from EBCDIC to ASCII at\r\nlocation x. The storage at location x and y must not overlap unless they specify the\r\nsame location.$PLIASCII(x,y,z)$x and y\r\nExpressions with type POINTER or OFFSET. If the type is OFFSET, the\r\nexpression must be an OFFSET variable declared with the AREA attribute.\r\nz Expression with computational type that is converted to FIXED BIN(31,0).
PLICANC = This built-in subroutine allows you to cancel the automatic restart facility.$PLICANC()$For more information about using PLICANC, see the Programming Guide.
PLICKPT = This built-in subroutine allows you to take a checkpoint for later restart.$PLICKPT(argument ),argument$For more information about using PLICKPT, see the Programming Guide.
PLIDELETE = This built-in subroutine frees the storage associated with the handle x.$PLIDELETE(x)$x Handle expression.\r\nPLIDELETE(x) is the best way to free the storage associated with a handle; this\r\nstorage is usually acquired by the NEW type function.\r\nCALL PLIDELETE(x) is equivalent to CALL PLIFREE(PTRVALUE(x)).
PLIDUMP = This built-in subroutine allows you to obtain a formatted dump of selected parts of\r\nstorage used by your program.$PLIDUMP(argument ),argument$For more information about using PLIDUMP, see the Programming Guide.
PLIEBCDIC = PLIEBCDIC converts Z storage units (bytes) at location y from ASCII to EBCDIC at\r\nlocation x. The storage at location x and y must not overlap unless they specify the\r\nsame location.$PLIEBCDIC(x,y,z)$x and y\r\nExpressions with type POINTER or OFFSET. If the type is OFFSET, the\r\nexpression must be an OFFSET variable declared with the AREA attribute.\r\nz Expression with computational type that is converted to FIXED BIN(31,0).
PLIFILL = This built-in subroutine moves z copies of the byte y to the location x without any\r\nconversions, padding, or truncation.$PLIFILL(x,y,z)$x Expression. x must be declared POINTER or OFFSET. If it is OFFSET, x must\r\nbe declared with the AREA attribute.\r\ny Must be declared CHARACTER(1) NONVARYING.\r\nz Expression that is converted to FIXED BINARY(31,0).\r\nExample\r\ndcl 1 Str1,\r\n2 B fixed bin(31),\r\n2 C pointer,\r\n2 * union,\r\n3 D char(4),\r\n3 E fixed bin(31),\r\n3 *,\r\n4 * char(3),\r\n4 F fixed bin(8) unsigned,\r\n2 * char(0)\r\ninitial call plifill( addr(Str1), '00'x, stg(Str1) );
PLIFREE = This built-in subroutine frees the heap storage associated with the pointer p that\r\nwas allocated using the ALLOCATE built-in function.$PLIFREE(p)$p Locator expression.\r\nPLIFREE is the opposite of ALLOCATE (ALLOC).
PLIMOVE = This built-in subroutine moves z storage units (bytes) from location y to location x,\r\nwithout any conversions, padding, or truncation. Unlike the PLIOVER built-in\r\nsubroutine, storage at locations x and y is assumed to be unique. If storage\r\noverlaps, unpredictable results can occur.$PLIMOVE(x,y,z)$x and y\r\nExpressions declared as POINTER or OFFSET. If the type is OFFSET, x or y\r\nmust be declared with the AREA attribute.\r\nz Expression. z must have a computational type and is converted to FIXED\r\nBINARY(31,0).\r\nExample\r\ndcl 1 Str1,\r\n2 B fixed bin(31),\r\n2 C pointer,\r\n2 * union,\r\n3 D char(4),\r\n3 E fixed bin(31),\r\n3 *,\r\n4 * char(3),\r\n4 F fixed bin(8) unsigned,\r\n2 * char(0);\r\ndcl 1 Template nonasgn static,\r\n2 * fixed bin(31) init(200),\r\n2 * pointer init(null()),\r\n2 * char(4) init(''),\r\n2 * char(0);\r\ncall plimove(addr(Str1), addr(Template), stg(Str1));
PLIOVER = This built-in subroutine moves z storage units (bytes) from location y to location x,\r\nwithout any conversions, padding, or truncation. Unlike the PLIMOVE built-in\r\nsubroutine, the storage at locations x and y can overlap.$PLIOVER(x,y,z)$x and y\r\nExpressions declared as POINTER or OFFSET. If the type is OFFSET, x or y\r\nmust be declared with the AREA attribute.\r\nz Expression. z must have a computational type and is converted to FIXED\r\nBINARY(31,0).\r\nUsage of PLIOVER is the same as PLIMOVE, with the exception that storage\r\nfor x and y can overlap (see ?PLIMOVE? on page 592).
PLIREST = This built-in subroutine allows you to restart program execution.$PLIREST()$For more information about using PLIREST, see the Programming Guide.
PLIRETC = This built-in subroutine allows you to set a return code that can be examined by\r\nthe program that invoked this PL/I program or by another PL/I procedure via the\r\nPLIRETV built-in function.$PLIRETC(x)$x An expression yielding a FIXED BINARY(31,0) return code.
PLIRETV = PLIRETV returns a FIXED BINARY(31,0) value that is the PL/I return code.$PLIRETV()$The value of the PL/I return code is the most recent value specified by a CALL\r\nPLIRETC statement.
PLISAXA = This built-in subroutine allows you to perform SAX-style parsing of an XML\r\ndocument residing in a buffer in your program.$PLISAXA(e,p,x,n ),c$e An event structure\r\np A pointer value or "token" that will be passed back to the parsing events\r\nx The address of the buffer containing the input XML\r\nn The number of bytes of data in that buffer\r\nc A numeric expression specifying the purported codepage of that XML\r\nNote that if the XML is contained in a CHARACTER VARYING or a WIDECHAR\r\nVARYING string, then the ADDRDATA built-in function should be used to obtain\r\nthe address of the first data byte.\r\nAlso note that if the XML is contained in a WIDECHAR string, the value for the\r\nnumber of bytes is twice the value returned by the LENGTH built-in function.\r\nFor more information, see the Programming Guide.
PLISAXB = This built-in subroutine allows you to perform SAX-style parsing of an XML\r\ndocument residing in a file.$PLISAXB(e,p,x ),c$e An event structure\r\np A pointer value or "token" that will be passed back to the parsing events\r\nx A character string expression specifying the input file\r\nc A numeric expression specifying the purported codepage of that XML\r\nFor more information, see the Programming Guide.
PLISAXC = This built-in subroutine allows you to perform SAX-style parsing of an XML\r\ndocument residing in one or more buffers in your program.$PLISAXC(e,p,x,n ),c$e An event structure\r\np A pointer value or "token" that will be passed back to the parsing events\r\nx The address of the buffer containing the XML document\r\nn The number of bytes of data in that buffer\r\nc A numeric expression specifying the codepage of that XML document\r\nPLISAXC uses the z/OS XML System Services parser and is supported only on\r\nz/OS.\r\nFor more information, see Enterprise PL/I for z/OS Programming Guide.
PLISAXD = The PLISAXD built-in subroutine provides SAX-style parsing with XML validation\r\nof an XML document.$PLISAXD(e,p,x,n,o ),c$e An event structure\r\np A pointer value or "token" that will be passed back to the parsing events\r\nx The address of s buffer that contains the XML document\r\nn The number of bytes of data in that buffer\r\no The address of a buffer that contains an Optimized Schema Representation\r\n(OSR)\r\nc A numeric expression specifying the codepage of that XML document\r\nPLISAXD uses the z/OS XML System Services parser and is supported only on\r\nz/OS.\r\nFor more information, see the chapter Using the PLISAXD XML parser in Enterprise\r\nPL/I for z/OS Programming Guide.\r\nNote: An OSR is a pre-processed version of a schema. For more information about\r\nOSR, see XML System Services User's Guide and Reference.
PLISRTA = This built-in subroutine allows you to sort an input file to produce a sorted output\r\nfile.$PLISRTA( argument )$For more information, see the Programming Guide.
PLISRTB = This built-in subroutine allows you to sort input records provided by an E15 PL/I\r\nexit procedure to produce a sorted output file.$PLISRTB( argument )$For more information, see the Programming Guide.
PLISRTC = This built-in subroutine allows you to sort an input file to produce sorted records\r\nthat are processed by an E35 PL/I exit procedure.$PLISRTC( argument )$For more information, see Enterprise PL/I for z/OS Programming Guide.
PLISRTD = This built-in subroutine allows you to sort input records provided by an E15 PL/I\r\nexit procedure to produce sorted records that are processed by an E35 PL/I exit\r\nprocedure.$PLISRTD( argument )$For more information, see the Programming Guide.
PLITRAN11 = PLITRAN11 translates one-byte data from a source buffer to one-byte data in a\r\ntarget buffer.$PLITRAN11 ( p , q , n , t )$p Address of the target buffer.\r\nq Address of the source buffer.\r\nn Length of the source buffer.\r\nt Address of the 256-byte translate table.\r\nThe buffer length must have computational type and will be converted to FIXED\r\nBINARY(31,0).\r\nThe buffer length must be nonnegative.\r\nThe target buffer must be at least as large as the source buffer.\r\nThe translate table must be aligned on a doubleword boundary.
PLITRAN12 = PLITRAN12 translates one-byte data from a source buffer to two-byte data in a\r\ntarget buffer.$PLITRAN12 ( p , q , n , t )$p Address of the target buffer.\r\nq Address of the source buffer.\r\nn Length of the source buffer.\r\nt Address of the 512-byte translate table.\r\nThe buffer length must have computational type and will be converted to FIXED\r\nBINARY(31,0).\r\nThe buffer length must be nonnegative.\r\nThe target buffer must be at least twice as large as the source buffer.\r\nThe translate table must be aligned on a doubleword boundary.
PLITRAN21 = PLITRAN21 translates two-byte data from a source buffer to one-byte data in a\r\ntarget buffer.$PLITRAN21 ( p , q , n , t )$p Address of the target buffer.\r\nq Address of the source buffer.\r\nn Length of the source buffer.\r\nt Address of the 64K-byte translate table.\r\nThe buffer length must have computational type and will be converted to FIXED\r\nBINARY(31,0).\r\nThe buffer length must be nonnegative.\r\nThe target buffer must be at least half as large as the source buffer.\r\nThe translate table must be aligned on a doubleword boundary.
PLITRAN22 = PLITRAN22 translates two-byte data from a source buffer to two-byte data in a\r\ntarget buffer.$PLITRAN22 ( p , q , n , t )$p Address of the target buffer.\r\nq Address of the source buffer.\r\nn Length of the source buffer.\r\nt Address of the 128K-byte translate table.\r\nThe buffer length must have computational type and will be converted to FIXED\r\nBINARY(31,0).\r\nThe buffer length must be nonnegative.\r\nThe target buffer must be at least as large as the source buffer.\r\nThe translate table must be aligned on a doubleword boundary.
POINTER = POINTER returns a pointer value that identifies the generation specified by an\r\noffset reference x, in an area specified by y. If x is the null offset value, the null\r\npointer value is returned.$POINTER(x,y)$Abbreviation: PTR\r\nx Offset reference. It can be the null offset value. If it is not, x must identify a\r\ngeneration of a based variable, but not necessarily in y. If it is not in y, the\r\ngeneration must be equivalent to a generation in y.\r\ny Area reference.\r\nGenerations of based variables in different areas are equivalent if, up to the\r\nallocation of the latest generation, the variables have been allocated and freed the\r\nsame number of times as each other.
POINTERADD = POINTERADD returns a pointer value that is the sum of its arguments.$POINTERADD(x,y)$Abbreviation: PTRADD\r\nx Pointer expression.\r\ny Expression that must have a computational type and is converted to FIXED\r\nBINARY(31,0).\r\nPOINTERADD can be used as a locator for a based variable.\r\nPOINTERADD can be used for subtraction by prefixing the operand to be\r\nsubtracted with a minus sign.\r\nThere is no need to use POINTERADD to increment a pointer - you can simply\r\nincrement the pointer as you would an integer. For example, there is no need to\r\nwrite:\r\np = pointeradd(p,2);\r\nInstead, you could write either of the following equivalent statements:\r\np = p + 2;\r\np += 2;\r\nHowever, POINTERADD can be useful in dereferencing the storage at a location\r\noffset from a pointer, as in the following example:\r\ndcl x fixed bin(31), b based fixed bin(31);\r\nx = pointeradd(p,2)->b;\r\nNote, however, since a locator in PL/I must be a reference, you cannot write\r\nx = (p + 2)->b;
POINTERDIFF = POINTERDIFF returns a FIXED BINARY(31,0) result that is the difference between\r\nthe two pointers x and y.$POINTERDIFF(x,y)$Abbreviation: PTRDIFF\r\nx and y\r\nExpressions declared as POINTER.
POINTERSUBTRACT = POINTERSUBTRACT is equivalent to POINTERADD(x,-y).$POINTERSUBTRACT(x,y)$Abbreviation: PTRSUBTRACT\r\nx Must be a pointer expression.\r\ny Expression that must have a computational type and is converted to FIXED\r\nBINARY(31,0).
POINTERVALUE = POINTERVALUE returns a pointer value that is the converted value of x.$POINTERVALUE(x)$Abbreviation: PTRVALUE\r\nx Expression that must have either the HANDLE attribute, or have a\r\ncomputational type. If x has a computational type, it is converted to FIXED\r\nBINARY(31,0).\r\nPOINTERVALUE(x) can be used to initialize static pointer variables if x is a\r\nconstant.
POLY = POLY returns a floating-point value that is an approximation of a polynomial\r\nformed from an one-dimensional array expressions x. The returned value has the\r\nsame attributes as the first argument. The syntax for POLY is:$POLY ( x , y )$x An array expression.\r\ny An element expression.\r\nx must be REAL FLOAT and y is converted to the attributes of x, if necessary.\r\nIf x has lower bound 0 and upper bound n, the result is a classic polynomial of\r\ndegree n in y with coefficients given by x, i.e. the result is\r\nx(0) + x(1)*y + x(2)*y**2 + ... + x(n)*y**n\r\nIn the general case, where x has lower bound m and upper bound n, the result is\r\nthe polynomial\r\nx(m) + x(m+1)*y + x(m+2)*y**2 + ... + x(n)*y**(n-m)
POPCNT = POPCNT returns a FIXED BIN value holding in each byte the number of bits equal\r\nto 1 in the corresponding byte of x.$POPCNT(x)$x Expression.\r\nx must have the attributes REAL FIXED BIN with a scale factor of zero.\r\nThe result has the same precision as x.\r\nThe result has the same (UN)SIGNED attribute as x.\r\nSee the following examples of using POPCNT:\r\nv POPCNT( '01020304'xn ) returns '01010201'xn.\r\nv POPCNT( '05060708'xn ) returns '02020301'xn.\r\nv If x has the attributes FIXED BIN(31), ISRL(POPCNT(x)*'01010101'xn,24) returns\r\nthe number of bits equal to 1 in x.\r\nOn z/OS, the POPCNT(x) built-in function requires an ARCH level of 9 or higher.
PRECISION = PRECISION returns the value of x, with a precision specified by p and q. The base,\r\nmode, and scale of the returned value are the same as that of x.$PRECISION(x,p ),q$Abbreviation: PREC\r\nx Expression.\r\np Restricted expression. p specifies the number of digits that the value of the\r\nexpression x is to have after conversion.\r\nq Restricted expression. It specifies the scaling factor of the result. For a\r\nfixed-point result, if q is omitted, a scaling factor of zero is assumed. For a\r\nfloating-point result, q must be omitted.
PRED = PRED returns a floating-point value that is the biggest representable number\r\nsmaller than x. It has the base, mode, and precision of x. OVERFLOW will be\r\nraised if there is no such number.$PRED(x)$x REAL FLOAT expression.\r\nPRED(TINY(X)) will return zero and will not raise UNDERFLOW.
PRESENT = PRESENT(x) returns a BIT(1) value that is '1'B if the parameter x was present in\r\nthe invocation of its containing procedure.$PRESENT(x)$x Level-1 unsubscripted BYADDR parameter.\r\nNote: This argument must be declared as OPTIONAL in the corresponding\r\nENTRY declaration in the calling code.
PROCEDURENAME = PROCEDURENAME() returns a nonvarying character string containing the name\r\nof the procedure in which this built-in function is invoked.$PROCEDURENAME ( )$Abbreviation: PROCNAME\r\nPROCEDURENAME always returns the leftmost name of a multiple label\r\nspecification, regardless of which name appears in the CALL or GOTO statement.
PROD = PROD returns the product of all the elements in x.$PROD(x)$x Array expression. If the elements of x are strings, they are converted to\r\nfixed-point integer values.\r\nIf the elements of x are not fixed-point integer values or strings, they are\r\nconverted to floating-point and the result is floating-point.\r\nThe result has the precision of x, except that the result for fixed-point integer\r\nvalues and strings is fixed-point with precision (n,0), where n is the maximum\r\nnumber of digits allowed. The base and mode match the converted argument x.
PUTENV = This function adds new environment variables or modifies the values of existing\r\nenvironment variables.$PUTENV(string)$string\r\nA character string of the form envvarname=value.\r\nPUTENV returns true ('1'B) if successful and false ('0'B) otherwise.
RADIX = RADIX returns a FIXED BINARY(31,0) value that is the model-base used to\r\nrepresent the floating-point expression x.$RADIX(x)$x REAL FLOAT expression.\r\nRADIX(x) depends on the floating-point format used to represent x. It is:\r\nv 2 if x is held in IEEE binary floating point format\r\nv 10 if x is held in IEEE decimal floating point format\r\nv 16 if x is held in z/OS hexadecimal format\r\nRADIX(x) can be used in restricted expressions.
RAISE2 = RAISE2(x,n) returns the value x*(2**n)$RAISE2(x,n)$x Expression. x must have a computational type.\r\nn Expression. n must have a computational type.\r\nIf x is REAL FIXED BIN(p,0) and SIGNED, the result is SIGNED REAL FIXED\r\nBIN(r,0) where if p <= M1, r = M1; if p > M1, r = M2.\r\nIf x is REAL FIXED BIN(p,0) and UNSIGNED, the result is UNSIGNED REAL\r\nFIXED BIN(r+1,0) where if p <= (M1+1), r = (M1+1); if p > M1, r = (M2+1).\r\nOtherwise, x is converted to SIGNED REAL FIXED BIN(p,0) and the result has the\r\nsame attributes as above.\r\nIf n is negative or if n is greater than r, the result is undefined.\r\nNote: RAISE2(x,n) is equivalent to the assembler SLA(x,n).\r\nExample\r\nraise2(6,1) /* produces 12 */
RANDOM = RANDOM returns a FLOAT BINARY(53) random number generated using x as the\r\ngiven seed. If x is omitted, the random number generated is based on the seed\r\nprovided by the last RANDOM invocation with a seed, or on a default initial seed\r\nof 1 if RANDOM has not previously been invoked with a seed.$RANDOM(x)$x Expression. x must have a computational type and should have an arithmetic\r\ntype. If x is numeric, it must be real. If x is not specified FIXED BINARY(31,0),\r\nit is converted.\r\nUnless 0 < x < 2,147,483,646, the ERROR condition is raised.\r\nThe values generated by RANDOM are uniformly distributed between 0 and 1,\r\nwith 0 < random(x) < 1. They are generated as follows using the multiplicative\r\ncongruential method:\r\nseed(x) = mod(950706376 * seed(x ? 1), 2147483647)\r\nrandom(x) = seed(x) / 2147483647\r\nThe seed is maintained at the program level and not within each thread in a\r\nmultithreading application.
RANK = RANK returns the integer value corresponding to a character or widechar.$RANK(x)$x Must have the attributes CHAR (1) NONVARYING or WCHAR (1)\r\nNONVARYING.\r\nIf x is character, RANK(x) is defined as index(collate(),x)-1, and RANK is the\r\ninverse of CHARVAL.\r\nIf x is widechar, RANK(x) is equal to UNSPEC(y) where y is x stored in bigendian\r\nformat.
REAL = REAL returns the real part of x. The result has the base, scale, and precision of x.$REAL(x)$x Expression. If x is real, it is converted to complex.\r\nREAL pseudovariable\r\nThe REAL pseudovariable assigns a real value or the real part of a complex value\r\nto the real part of x.\r\nx Complex reference.\r\nREAL pseudovariable
REG12 = REG12 returns a pointer that holds the current value of register 12.$REG12()$If the REG12 built-in function is used to change storage, unpredictable results may\r\noccur\r\nThe REG12 built-in function is supported only on z/OS.
REM = REM returns the remainder of x divided by y. This can be calculated by:\r\nx - y * trunc(x/y)$REM(x,y)$x and y\r\nExpressions. x and y must be computational and can be arithmetic.\r\nFor examples that contrast the REM and MOD built-in functions, refer to ?MOD?\r\non page 546.
REPATTERN = Takes a value holding a date in one pattern and returns that value converted to a\r\ndate in a second pattern.$REPATTERN(d ,p ,q ),w$d A string expression representing a date. The length of d must be at least as\r\nlarge as the length of the source pattern q. If d is larger, any excess characters\r\nmust be formed by leading blanks.\r\nd must have a computational type and should have character type. If not, it is\r\nconverted to character.\r\np The target pattern; must be one of the supported date/time patterns.\r\nq The source pattern; must be one of the supported date/time patterns.\r\nw Specifies an expression (such as 1950) that can be converted to an integer. If\r\nnegative, it specifies an offset to be subtracted from the value of the year when\r\nthe code runs. If omitted, w defaults to the value specified in the WINDOW\r\ncompile-time option.\r\nThe returned value has the attributes CHAR(m) NONVARYING where m is the\r\nlength of the target patter p.\r\nThe allowed patterns are listed in Table 51 on page 396. For an explanation of\r\nLilian format, see ?Date/time built-in functions? on page 394.\r\nThe REPATTERN built-in function will perform the specified conversion in-line\r\nwhen both of the following are true:\r\nv the source and target patterns do not use the DDD, MMM or Mmm elements\r\nv the source pattern has as much date information as the target, i.e. if the target\r\nhas a year, month or day, then the source must have the corresponding\r\ninformation and there must also be at least as many digits in the source year as\r\nin the target.\r\nSo, for example,\r\nv YYYYMMDD to DD.MM.YY will be inlined\r\nv MM/DD/YYYY to YYMM will be inlined\r\nv MMYY to YYYYMMDD will not be inlined\r\nThe following are some examples of how to use REPATTERN to convert between\r\n2-digit-year and 4-digit-year date patterns. But you can use this built-in function to\r\nconvert a date from any supported pattern to any other supported pattern even if\r\nthe patterns use the same number of digits to hold the year value.\r\nREPATTERN('990101','YYYYMMDD','YYMMDD', 1950) returns '19990101'\r\nREPATTERN('000101','YYYYMMDD','YYMMDD', 1950) returns '20000101'\r\nREPATTERN('19990101','YYMMDD','YYYYMMDD', 1950) returns '990101'\r\nREPATTERN('20000101','YYMMDD','YYYYMMDD', 1950) returns '000101'\r\nREPATTERN('19490101','YYMMDD','YYYYMMDD', 1950) raises ERROR
REPEAT = REPEAT returns a bit, character, graphic or widechar string consisting of x\r\nconcatenated to itself the number of times specified by y. That is, there are (y + 1)\r\noccurrences of x.$REPEAT(x,y)$x Bit, character, graphic or widechar expression to be repeated. If x is arithmetic,\r\nthe following conversions occur:\r\nv If it is binary, x is converted to bit string\r\nv If it is decimal, x is converted to character string.\r\ny Expression. If necessary, y is converted to a real fixed-point binary value.\r\nIf y is zero or negative, the string x is returned. For an example of the REPEAT\r\nbuilt-in function, see ?COPY? on page 442.
REPLACEBY2 = REPLACEBY2 returns a nonvarying string formed by replacing some of the\r\ncharacters in x by a pair of characters.$REPLACEBY2 ( x , y , z )$x Character expression to be searched for possible replacement of its characters.\r\ny Character expression containing the replacement pair values..\r\nz Character expression containing the characters that are to be replaced.\r\nREPLACEBY2 operates on each character of x as follows:\r\nIf a character in x is found in z, the character pair in y that corresponds to that in z\r\nis copied to the result; otherwise, the character in x is copied directly to the result.\r\nIf z contains duplicates, the leftmost occurrence is used.\r\nThe string y must be twice as long as the string z.\r\nAs an example, REPLACEBY2( 'R\u00e4tsel', 'aeoeuess', '\u00e4\u00f6\u00fc\u00df') returns the string\r\n'Raetsel'.
REVERSE = REVERSE returns a nonvarying string that contains the elements of x in reverse\r\norder.$REVERSE(x)$x Expression. x must have a computational type and should have a string type.\r\nIf x does not have a string type, it is converted to string (that is, from numeric\r\nto bit, character, graphic or widechar), according to the rules for concatenation.\r\nExample\r\ndcl Source char value('HARPO');\r\ndcl Target char(length(Source));\r\nTarget = reverse (Source); /* 'OPRAH' */
RIGHT = RIGHT returns a string that is the result of inserting string x at the right end of a\r\nstring with length n and padded on the left with the character z as needed. If z is\r\nomitted, a blank is used as the padding character.$RIGHT(x,n ),z$x Expression. x must have a computational type and can have a character type. If\r\nnot, it is converted to character.\r\nn Expression. n must have a computational type and is converted to FIXED\r\nBINARY(31,0).\r\nz Expression. If specified, z must have the type CHARACTER(1) NONVARYING\r\ntype.\r\nExample\r\ndcl Source char value('One Hundred SCIDS Marks');\r\ndcl Target char(30);\r\nTarget = right (Source, length(Target), '*');\r\n/* '*******One Hundred SCIDS Marks' */
ROUND = ROUND returns the value of x rounded at a digit specified by n. The result has the\r\nmode, base, and scale of x.$ROUND(x,n)$x Real expression. If x is negative, the absolute value is rounded and the sign is\r\nrestored.\r\nn Optionally-signed integer. It specifies the digit at which rounding is to occur.\r\nROUND of FIXED\r\nThe precision of a FIXED result is:\r\n(max(1,min(p-q+1+n,N)),n)\r\nWhere (p,q) is the precision of x, and N is the maximum number of digits allowed.\r\nHence, n specifies the scaling factor of the result.\r\nn must conform to the limits of scaling-factors for FIXED data. If n is greater than\r\n0, rounding occurs at the (n)th digit to the right of the point. If n is zero or\r\nnegative, rounding occurs at the (1-n)th digit to the left of the point.\r\nThe value of the result is given by the following formula, where b = 2 if x is\r\nBINARY and b = 10 if x is DECIMAL:\r\nround(x,n) = sign(x)*(b-n)* floor(abs(x)* (bn) + 1/2)\r\nSo, in the following example, the value 6.67 is output:\r\ndcl X fixed dec(5,4) init(6.6666);\r\nput skip list( round(X,2) );\r\nROUND of IEEE decimal floating point\r\nThe precision of an IEEE DECIMAL FLOAT result is the same as that of the source\r\nargument.\r\nThe value of the result is given by the following formula, where where b = 10\r\n(=radix(x)) and e = exponent(x):\r\nround(x,n) = sign(x)*(b(e-n))* floor(abs(x)* (b(n-e)) + 1/2)\r\nSo, if the FLOAT(DFP) compiler option is in effect, these successive roundings of\r\n3.1415926d0 would produce the following values:\r\ndcl x float dec(16) init( 3.1415926d0 );\r\ndisplay( round(x,1) ); /* 3.000000000000000E+0000 */\r\ndisplay( round(x,2) ); /* 3.100000000000000E+0000 */\r\ndisplay( round(x,3) ); /* 3.140000000000000E+0000 */\r\ndisplay( round(x,4) ); /* 3.142000000000000E+0000 */\r\ndisplay( round(x,5) ); /* 3.141600000000000E+0000 */\r\ndisplay( round(x,6) ); /* 3.141590000000000E+0000 */\r\nROUND of IEEE binary floating point\r\nThe precision of an IEEE binary floating point result is the same as that of the\r\nsource argument.\r\nUnder the compiler option USAGE(ROUND(IBM)), the value of the result is the\r\nsame as the source except on z/OS where if the source is not zero, then the result\r\nis obtained by turning on the rightmost bit in the source.\r\nUnder the compiler option USAGE(ROUND(ANS)), the value of the result is given\r\nby the following formula, where where b = 2 (=radix(x)) and e = exponent(x):\r\nround(x,n) = sign(x)*(b(e-n))* floor(abs(x)* (b(n-e)) + 1/2)\r\nNote that under USAGE(ROUND(ANS)), the rounding is a base 2 rounding, and\r\nthe results may not be what a naive user expects. For example, if compiled with\r\nUSAGE(ROUND(ANS)) and IEEE binary floating point instructions are used, these\r\nsuccessive roundings of 3.1415926d0 would produce the following values:\r\ndcl x float bin(53) init( 3.1415926d0 );\r\ndisplay( round(x,1) ); /* 4.000000000000000E+0000 */\r\ndisplay( round(x,2) ); /* 3.000000000000000E+0000 */\r\ndisplay( round(x,3) ); /* 3.000000000000000E+0000 */\r\ndisplay( round(x,4) ); /* 3.250000000000000E+0000 */\r\ndisplay( round(x,5) ); /* 3.125000000000000E+0000 */\r\ndisplay( round(x,6) ); /* 3.125000000000000E+0000 */\r\ndisplay( round(x,7) ); /* 3.156250000000000E+0000 */\r\nROUND of IBM hexadecimal floating point\r\nThe precision of an IBM hexadecimal floating point result is the same as that of the\r\nsource argument.\r\nUnder the compiler option USAGE(ROUND(IBM)), the value of the result is the\r\nsame as the source except on z/OS where if the source is not zero, then the result\r\nis obtained by turning on the rightmost bit in the source.\r\nUnder the compiler option USAGE(ROUND(ANS)), the value of the result is given\r\nby the following formula, where where b = 16 (=radix(x)) and e = exponent(x):\r\nround(x,n) = sign(x)*(b(e-n))* floor(abs(x)* (b(n-e)) + 1/2)\r\nNote that under USAGE(ROUND(ANS)), the rounding is a base 16 rounding, and\r\nthe results may not be what a naive user expects. For example, if compiled with\r\nUSAGE(ROUND(ANS)) and IBM hexadecimal floating point instructions are used,\r\nthese successive roundings of 3.1415926d0 would produce the following values:\r\ndcl x float bin(53) init( 3.1415926d0 );\r\ndisplay( round(x,1) ); /* 3.000000000000000E+00 */\r\ndisplay( round(x,2) ); /* 3.125000000000000E+00 */\r\ndisplay( round(x,3) ); /* 3.140625000000000E+00 */\r\ndisplay( round(x,4) ); /* 3.141601562500000E+00 */\r\ndisplay( round(x,5) ); /* 3.141586303710938E+00 */\r\ndisplay( round(x,6) ); /* 3.141592979431152E+00 */
ROUNDDEC = ROUNDDEC returns the value of x rounded at a digit specified by n. The result\r\nhas the mode, base, and scale of x.$ROUNDDEC(x,n)$x Real expression that is FIXED DECIMAL or DFP FLOAT. If x is negative, the\r\nabsolute value is rounded and the sign is restored.\r\nn Optionally-signed integer. It specifies the digit at which rounding is to occur.\r\nIf x is FIXED DECIMAL or PICTURE FIXED DECIMAL, ROUNDDEC produces\r\nthe same results as ROUND.\r\nIf x is FLOAT DECIMAL or PICTURE FLOAT DECIMAL and the FLOAT(DFP)\r\ncompiler option is in effect, ROUNDDEC rounds x at the nth decimal place rather\r\nthan at the nth digit (as would the ROUND built-in function in accordance with\r\nthe ANSI definition). For example, these successive roundings of\r\n3141.592653589793d0 would produce the following values:\r\ndcl x float dec(16) init( 3141.592653589793d0 );\r\ndisplay( fixed(rounddec(x,1),15,7) ); /* 3141.6000000 */\r\ndisplay( fixed(rounddec(x,2),15,7) ); /* 3141.5900000 */\r\ndisplay( fixed(rounddec(x,3),15,7) ); /* 3141.5930000 */\r\ndisplay( fixed(rounddec(x,4),15,7) ); /* 3141.5927000 */\r\ndisplay( fixed(rounddec(x,5),15,7) ); /* 3141.5926500 */\r\ndisplay( fixed(rounddec(x,6),15,7) ); /* 3141.5926540 */\r\ndisplay( fixed(rounddec(x,7),15,7) ); /* 3141.5926536 */\r\nROUNDDEC complements the CEIL, FLOOR, and TRUNC built-in functions.\r\nv When the value of n is zero, ROUNDDEC rounds x half away from zero.\r\nv Under CEIL, ROUNDDEC rounds x half up, or rounds half towards plus\r\ninfinity.\r\nv Under FLOOR, ROUNDDEC rounds x half down way, or rounds half towards\r\nminus infinity.\r\nv Under TRUNC, ROUNDDEC rounds x half to zero.
SAMEKEY = SAMEKEY returns a bit string of length 1 indicating whether a record that has\r\nbeen accessed is followed by another with the same key.$SAMEKEY(x)$x File reference. The file must have the RECORD attribute.\r\nUpon successful completion of an input/output operation on file x, or immediately\r\nbefore the RECORD condition is raised, the value accessed by SAMEKEY is set to\r\n'1'B if the record processed is followed by another record with the same key, and\r\nset to '0'B if it is not.\r\nThe value accessed by SAMEKEY is also set to '0'B if:\r\nv An input/output operation that raises a condition other than RECORD also\r\ncauses file positioning to be changed or lost\r\nv The file is not open\r\nv No current cursor position exists in the file.
SCALE = SCALE returns a floating-point value based on the following formula:\r\nn\r\nx*(radix(x) )\r\nThe result has the base, mode, and precision of x.$SCALE(x,n)$x REAL FLOAT expression.\r\nn Expression that must have a computational type and is converted to FIXED\r\nBINARY(31,0).
SEARCH = SEARCH returns an unscaled REAL FIXED BINARY value specifying the first\r\nposition in one string at which any character, bit, graphic or widechar of another\r\nstring appears. It also allows you to specify the location at which to start searching.$SEARCH(x,y ),n$x and y\r\nExpressions. x specifies the string in which to search for any character, bit,\r\ngraphic or widechar that appears in string y.\r\nIf either x or y are the null string, the result is zero.\r\nIf y does not occur in x, the result is zero.\r\nn Expression. n specifies the location within x at which to begin searching. It\r\nmust have a computational type and is converted to FIXED BINARY(31,0).\r\nUnless 1 ? n ? LENGTH(x)+1, STRINGRANGE condition, if enabled, is raised.\r\nIts implicit action and normal return give a result of zero.\r\nThe BIFPREC compiler option determines the precision of the result returned.\r\nSEARCH can be used to find delimiters in a string of numbers.\r\nExample\r\ndcl Source char value(' Our PL/I wields the Power ');\r\ndcl Pos fixed bin(31);\r\n/* Find occurrences of any of the characters 'P','o',or 'w' in source * /\r\nPos = search (Source, 'Pow'); /* returns 6 for the 'P' */\r\nPos = search (Source, 'Pow', Pos+1); /* returns 11 for the 'w' */\r\nPos = search (Source, 'Pow', Pos+1); /* returns 22 for the 'P' */\r\nPos = search (Source, 'Pow', Pos+1); /* returns 23 for the 'o' */\r\nPos = search (Source, 'Pow', Pos+1); /* returns 24 for the 'w' */\r\nPos = index (source, 'Pow',1); /* returns 22 for the 'Pow' */\r\nIn the above example, SEARCH returns the position at which any of the three\r\ncharacters ('P', 'o', or 'w') appear. INDEX returns the position at which the whole\r\nstring 'Pow' appears.\r\nExample\r\ndcl Source char value (' 368,475;121.,856,478')\r\ndcl Delims char(3) init (',;.'); /* string of delimiters */\r\ndcl Number(5) char(3);\r\ndcl Start fixed bin(31);\r\ndcl End fixed bin(31);\r\n/* Extract the three-digit numbers from the source string */\r\n/* by searching for the delimiters */\r\nStart = verify (Source, ' ');\r\n/* find start of first number */\r\nEnd = search (Source, ',;.', Start );\r\n/* find end of first number */\r\nif End = 0 then\r\nEnd = length (Source) + 1;\r\nNumber(1) = substr (Source, Start, 3); /* 368 */\r\nStart = verify (Source, Delims, End);\r\n/* find start of second number */\r\nEnd = search (Source, Delims, Start );\r\nNumber(2) = substr (Source, Start, 3); /* 475 */
SEARCHR = null$SEARCHR(x,y ),n$The SEARCHR function performs the same operation as the SEARCH built-in\r\nfunction except for the following differences:\r\nv The search is done from right to left.\r\nv The default value for n is LENGTH(x).\r\nv Unless 0 ? n ? LENGTH(x), the STRINGRANGE condition, if enabled, is raised.\r\nIts implicit action and normal return give a result of zero.\r\nThe BIFPREC compiler option determines the precision of the result returned.\r\nThe syntax for SEARCH is described in ?SEARCH? on page 640.\r\nExample\r\ndcl Source char value (' 555 Bailey Ave, San Jose, CA 95141, USA');\r\ndcl Digits char value ('0123456789');\r\ndcl (Start, End) fixed bin(31);\r\ndcl Num char(20) var;\r\n/* Find last number (i.e., zip code) */\r\nEnd = searchr (Source, Digits); /* returns 35 for the '1' */\r\nStart = verifyr (Source, Digits, End); /* returns 30 for the ' ' */\r\nNum = substr (Source, Start + 1, End ? Start); /* extract number */
SECS = SECS returns a FLOAT BINARY(53) value which is the number of seconds (based\r\non Lilian format) corresponding to the date d.$SECS( )d,p,w$d A string expression representing a date. If present, d specifies the input date as\r\na character string representing the date/time specified in the pattern p. If d is\r\nmissing, it is assumed to be DATETIME().\r\nd must have a computational type and should have character type. If not, it is\r\nconverted to character.\r\np One of the supported date/time patterns. If p is omitted, it is assumed to be\r\nthe default date/time pattern 'YYYYMMDDHHMISS999'.\r\np must have a computational type and should have character type. If not, it is\r\nconverted to character.\r\nw Specifies an expression (such as 1950) that can be converted to an integer. If\r\nnegative, it specifies an offset to be subtracted from the value of the year when\r\nthe code runs. If omitted, w defaults to the value specified in the WINDOW\r\ncompile-time option.\r\nThe allowed patterns are listed in Table 51 on page 396. For an explanation of\r\nLilian format, see ?Date/time built-in functions? on page 394.\r\nExample\r\ndcl Dayname (7) char(9) var static nonasgn init( 'Sunday',\r\n'Monday',\r\n'Tuesday',\r\n'Wednesday',\r\n'Thursday',\r\n'Friday',\r\n'Saturday');\r\ndcl Jul4_1776_Secs float bin(53);\r\ndcl Age_Tot_Secs pic 'Z,ZZZ,ZZZ,ZZZ,ZZ9';\r\nJul4_1776_Secs = secs('17760704','YYYYMMDD'); /* seconds */\r\nAge_Tot_Secs = secs() ? Jul4_1776_Secs; /* seconds since */\r\ndisplay ('USA became independent on ' \\r\ndayname(weekday(secstodays(Jul4_1776_Secs))) \\r\n', July 4, 1776 and at this very moment it has been ' \\r\nAge_Tot_Secs, \ ' seconds.');
SECSTODATE = SECSTODATE returns a nonvarying character string containing the date in the\r\ndate/time pattern specified by p that corresponds to d seconds (based on Lilian\r\nformat).$SECSTODATE ( d ),p,w$d The number of seconds (in Lilian format). d must have a computational type\r\nand is converted to FLOAT BIN(53) if necessary.\r\np One of the supported date/time patterns. If omitted, p is assumed to be the\r\ndefault date/time pattern 'YYYYMMDDHHMISS999' (the default format\r\nreturned by DATETIME).\r\nw Specifies an expression (such as 1950) that can be converted to an integer. If\r\nnegative, it specifies an offset to be subtracted from the value of the year when\r\nthe code runs. If omitted, w defaults to the value specified in the WINDOW\r\ncompile-time option.\r\nThe allowed patterns are listed in Table 51 on page 396. For an explanation of\r\nLilian format, see ?Date/time built-in functions? on page 394.
SECSTODAYS = SECSTODAYS returns a FIXED BINARY(31,0) value that represents the number of\r\nseconds x converted to days, ignoring incomplete days.$SECSTODAYS(x)$x Expression. The value for x must have computational type and should be\r\nFLOAT BINARY(53). If not, it is converted to FLOAT BINARY(53).\r\nSECSTODAYS(x) is the same as x?(24*60*60).\r\nFor an example, see ?SECS? on page 643.
SIGN = SIGN returns an unscaled REAL FIXED BINARY value that indicates whether x is\r\npositive, zero, or negative.$SIGN(x)$x Real expression.\r\nThe returned value is given by:\r\nValue of x Value Returned\r\nx > 0 +1\r\nx = 0 0\r\nx < 0 ?1\r\nThe BIFPREC compiler option determines the precision of the result returned.
SIGNED = SIGNED returns a signed FIXED BINARY value of x, with a precision specified by\r\np and q.$SIGNED(x ),p,q$x Expression.\r\np Restricted expression that specifies the number of digits to be maintained\r\nthroughout the operation.\r\nq Restricted expression that specifies the scaling factor of the result. For a\r\nfixed-point result, if p is given and q is omitted, a scaling factor of zero is the\r\ndefault.
SIN = SIN returns a floating-point value that is an approximation of the sine of x. It has\r\nthe base, mode, and precision of x.$SIN(x)$x Expression whose value is in radians.
SIND = SIND returns a real floating-point value that is an approximation of the sine of x. It\r\nhas the base and precision of x.$SIND(x)$x Real expression whose value is in degrees.
SINH = SINH returns a floating-point value that represents an approximation of the\r\nhyperbolic sine of x. It has the base, mode, and precision of x.$SINH(x)$x Expression whose value is in radians.
SIZE = SIZE returns a FIXED BINARY value giving the implementation-defined storage, in\r\nbytes, allocated to a variable x.$SIZE(x)$x A variable of any data type, data organization, alignment, and storage class,\r\nexcept as listed below.\r\nx cannot be:\r\nv A BASED, DEFINED, parameter, subscripted, or structure or union\r\nbase-element variable that is an unaligned fixed-length bit string\r\nv A minor structure or union whose first or last base element is an unaligned\r\nfixed-length bit string (except where it is also the first or last element of the\r\ncontaining major structure or union)\r\nv A major structure or union that has the BASED, DEFINED, or parameter\r\nattribute, and which has an unaligned fixed-length bit string as its first or\r\nlast element\r\nv A variable not in connected storage\r\nThe value returned by SIZE(x) is the maximum number of bytes that could be\r\ntransmitted in the following circumstances:\r\ndeclare F file record input\r\nenvironment(scalarvarying);\r\nread file(F) into(x);\r\nIf x is:\r\nv A varying-length string, the returned value includes the length-prefix of the\r\nstring and the number of bytes in the maximum length of the string\r\nv An area, the returned value includes the area control bytes and the maximum\r\nsize of the area\r\nv An aggregate containing areas or varying-length strings, the returned value\r\nincludes the area control bytes, the maximum sizes of the areas, the length\r\nprefixes of the strings, and the number of bytes in the maximum lengths of the\r\nstrings.\r\nThe SIZE built-in function must not be used on a BASED variable with adjustable\r\nextents if that variable has not been allocated.\r\nUnder the CMPAT(V3) compiler option, SIZE returns a FIXED BIN(63) value.\r\nUnder all other CMPAT options, it returns a FIXED BIN(31) value.\r\nTo get the number of bytes currently required by a variable, as opposed to the\r\nnumber of bytes allocated to it, use the CURRENTSIZE built-in function. See\r\n?CURRENTSIZE? on page 449 for more details.\r\nExample\r\ndcl Scids char(17) init('See you at SCIDS!') static;\r\ndcl Vscids char(20) varying init('See you at SCIDS!') static;\r\ndcl Stg fixed bin(31);\r\nStg = storage (Scids); /* 17 bytes */\r\nStg = currentsize (Scids); /* 17 bytes */\r\nStg = size (Vscids); /* 22 bytes */\r\nStg = currentsize (Vscids); /* 19 bytes */\r\nStg = size (Stg); /* 4 bytes */\r\nStg = currentsize (Stg); /* 4 bytes */
SOURCEFILE = SOURCEFILE returns a nonvarying character string containing the name of the file\r\nthat contains the statement where this function is invoked.$SOURCEFILE()$SOURCEFILE can be used in restricted expressions.\r\nThe string returned is system dependent and should be used for tracing and\r\ndebugging purposes only.
SOURCELINE = SOURCELINE() returns a FIXED BINARY(31,0) value that is the line number of the\r\nstatement where this function is invoked, within the file that contains that\r\nstatement. If the statement extends over several source lines, the number returned\r\nis that of the line on which the statement starts.$SOURCELINE ( )$SOURCELINE() can be used in restricted expressions.
SQRT = SQRT returns a floating-point value that is an approximation of the positive square\r\nroot of x. It has the base, mode, and precision of x.$SQRT(x)$x Expression. If x is real, it must not be less than zero.
SQRTF = SQRTF is the same as SQRT except for these differences:\r\nv SQRTF calculates its result inline if hardware architecture permits.\r\nv The argument must be real.\r\nv Invalid arguments will generate hardware exceptions.\r\nv The accuracy of the result is set by the hardware.\r\nSQRTF is not supported for DFP.\r\nFor the definition and syntax, see ?SQRT? on page 655.\r\nSTACKADDR\r\nSTACKADDR returns the address of the dynamic save area (DSA) for the\r\nprocedure (or BEGIN block) in which it is invoked.$STACKADDR()$If the STACKADDR built-in function is used to change storage, unpredictable\r\nresults may occur\r\nSTACKADDR
STORAGE = Abbreviation: STG\r\nSTORAGE is a synonym for SIZE. See the syntax for ?SIZE? on page 651.$null$null
STRING = STRING returns a string that is the concatenation of all the elements of x.$STRING(x)$x Aggregate or element reference.\r\nSTRING is restricted as follows:\r\nv It cannot be applied to unions or structures containing unions.\r\nv If applied to a scalar, the scalar must be a bit string, a character string, a\r\npictured character string, a pictured numeric string, a graphic string, or a\r\nwidechar string.\r\nv If applied to a structure, the structure must contain no padding bytes and the\r\nelements of the structure must be either:\r\n? All unaligned bit strings\r\n? All character strings, each of which is either a character string, a pictured\r\nstring, or a pictured numeric string\r\n? All graphic strings\r\n? All widechar strings\r\nv If applied to an array, all elements in the array are subject to the restrictions as\r\ndescribed previously.\r\nThe type of string returned has the same type as one of these base elements with\r\nthese exceptions:\r\nv if any of the base elements are PICTUREs, then the type returned has\r\nCHARACTER type.\r\nv If any of the base elements have the GRAPHIC type, then the type returned is\r\nGRAPHIC unless the STRINGOFGRAPHIC compiler options specifies that it\r\nshould be CHARACTER.\r\nThe following are valid STRING targets:\r\ndcl\r\n1 A,\r\n2 B bit(8),\r\n2 C bit(2),\r\n2 D bit(8);\r\ndcl\r\n1 W,\r\n2 X char(2),\r\n2 Y pic'aa',\r\n2 Z char(6);\r\ndcl\r\n1 W,\r\n2 X char(2),\r\n2 Y pic'99',\r\n2 Z char(6);\r\nThe following are invalid STRING targets:\r\ndcl\r\n1 A,\r\n2 B bit(8) aligned,\r\n2 C bit(2),\r\n2 D bit(8) aligned;\r\nSTRING pseudovariable\r\nThe STRING pseudovariable assigns a string to x as if x were a string scalar. Any\r\nremaining strings in x are filled with blanks or zero bits, or, if varying-length, are\r\ngiven zero length.\r\nx Aggregate or element reference. Each base element of x must be either all\r\nbit-string or all character-string.\r\nThe STRING pseudovariable must not be used out of context.\r\nThe pseudovariable is also subject to the restrictions of the STRING built-in\r\nfunction. For more information on the restrictions, refer to 659.\r\nSTRING pseudovariable
SUBSTR = SUBSTR returns a substring, specified by y and z, of x.$SUBSTR(x,y ),z$x String expression. It specifies the string from which the substring is extracted.\r\nIf x is not a string, it is converted to character.\r\ny Expression that is converted to FIXED BINARY(31,0). y specifies the starting\r\nposition of the substring in x.\r\nz Expression that is converted to FIXED BINARY(31,0). z specifies the length of\r\nthe substring in x. If z is zero, a null string is returned. If z is omitted, the\r\nsubstring returned is position y in x to the end of x.\r\nThe STRINGRANGE condition is raised if z is negative or if the values of y and z\r\nare such that the substring does not lie entirely within the current length of x. It is\r\nnot raised when y = LENGTH(x)+1 and z = 0. For an example of the SUBSTR\r\nbuilt-in function, see ?SEARCH? on page 640.\r\nSUBSTR pseudovariable\r\nThe SUBSTR pseudovariable assigns a string value to a substring, specified by y\r\nand z, of x. The remainder of x is unchanged. Assignments to a varying string do\r\nnot change the length of the string.\r\nx String-reference. x must not be a numeric character.\r\ny Expression. y expression that can be converted to a FIXED BINARY value\r\nwhich specifies the starting position of the substring in x.\r\nz Expression. z specifies the length of the substring in x. It can be converted to a\r\nreal fixed-point binary value. If z is zero, a null string is returned. If z is\r\nomitted, the substring returned is position y in x to the end of x.\r\ny and z can be arrays only if x is an array.\r\nSUBSTR pseudovariable
SUBTRACT = SUBTRACT is equivalent to ADD(x,-y,p,q).$SUBTRACT(x,y,p ),q$For details about arguments, refer to ?ADD? on page 408 for argument\r\ndescriptions.
SUCC = SUCC returns a floating-point value that is the smallest representable number\r\nlarger than x. It is the base, mode, and precision of x. The OVERFLOW condition is\r\nraised if there is no such number.$SUCC(x)$x REAL FLOAT expression.\r\nSUCC satisfies the following relationships:\r\npred(succ(x)) = x\r\nsucc(pred(x)) = x\r\nsucc(x) = -pred(-x)\r\nsucc(0d0) = tiny(0d0)
SUM = SUM returns the sum of all the elements in x. The base, mode, and scale of the\r\nresult match those of x.$SUM(x)$x Array expression. If the elements of x are strings, they are converted to\r\nfixed-point integer values.\r\nIf the elements of x are fixed-point, the precision of the result is (N,q), where N\r\nis the maximum number of digits allowed, and q is the scaling factor of x.\r\nIf the elements of x are floating-point, the precision of the result matches x.
SYSNULL = SYSNULL returns the system null pointer value. You can assign SYSNULL to\r\nhandles and compare it with handles. You can use SYSNULL to initialize static\r\npointer and offset variables.$SYSNULL()$Note: NULL and SYSNULL may compare equal; however, you should not write\r\ncode that depends on their equality.\r\nSee also ?NULL? on page 549.
SYSTEM = SYSTEM(x) returns a FIXED BIN(31,0) value that is the return value from the\r\ncommand processor when it is invoked with the command contained in x.$SYSTEM(x)$x Must have a computational type and should have characater type. If not, x is\r\nconverted to character.
TALLY = TALLY returns a FIXED BINARY(31,0) result that indicates the number of times\r\nstring y appears in string x. If y does not appear in x, a value of 0 is returned.$TALLY(x,y)$x and y\r\nString expressions.\r\nBoth x and y must have computational type and should be character, bit,\r\ngraphic or widechar type.\r\nIf either x or y are the null string, the result is zero.\r\nExample\r\nTALLY ('We''ve got the Power!', 'power'); /* returns 0 */\r\nTALLY ('We''ve got the Power!', 'Power'); /* returns 1 */\r\nTALLY ('We''ve got the Power!', ' '); /* returns 3 */\r\nTALLY ('We''ve got the Power!', 'e'); /* returns 4 */\r\nTALLY ('1001'B, '1'B); /* returns 2 */
TAN = TAN returns a floating-point value that is an approximation of the tangent of x. It\r\nhas the base, mode, and precision of x.$TAN(x)$x Expression whose value is in radians.
TAND = TAND returns a real floating-point value that is an approximation of the tangent of\r\nx. It has the base and precision of x.$TAND(x)$x Real expression whose value is in degrees.
TANH = TANH returns a floating-point value that is an approximation of the hyperbolic\r\ntangent of x. It has the base, mode, and precision of x.$TANH(x)$x Expression whose value is in radians.
THREADID = THREADID (short for thread identifier) returns a POINTER value that is the\r\naddress of the operating system thread identifier for an attached thread.$THREADID ( x )$x Task reference. The value of x should have been set previously in the THREAD\r\noption of the ATTACH statement.\r\nThe value returned by this built-in function can be used to invoke system\r\nfunctions, such as DosSetPriority, on Windows, or posix functions on z/OS.\r\nTo obtain the system thread identifier for the currently executing thread, you must\r\ninvoke the function appropriate for the platform on which that thread is running.\r\nSo, on Windows, you should invoke GetCurrentThreadId, and on z/OS, you\r\nshould invoke pthread_self.
TIME = TIME returns a character string timestamp in the format HHMISS999.$TIME()$null
TINY = TINY returns a floating-point value that is the smallest positive value x can\r\nassume. It has the base, mode, and precision, of x.$TINY(x)$x REAL FLOAT expression.\r\nTINY(x) is a constant and can be used in restricted expressions.
TRANSLATE = TRANSLATE returns a character string of the same length as x.$TRANSLATE(x,y ),z$x Character expression to be searched for possible translation of its characters.\r\ny Character expression containing the translation values of characters.\r\nz Character expression containing the characters that are to be translated. If z is\r\nomitted, it defaults to collate().\r\nTRANSLATE operates on each character of x as follows:\r\nIf a character in x is found in z, the character in y that corresponds to that in z is\r\ncopied to the result; otherwise, the character in x is copied directly to the result. If\r\nz contains duplicates, the leftmost occurrence is used.\r\ny is padded with blanks, or truncated, on the right to match the length of z.\r\nAny arithmetic or bit arguments are converted to character.\r\nTRANSLATE does not support GRAPHIC or WIDECHAR data.\r\nTRANSLATE will perform best when the second and third arguments are either\r\nliterals, named constants declared with the VALUE attribute, or restricted\r\nexpressions.\r\nExample\r\ndcl source char value("Ein Raetsel gibt es nicht.");\r\ndcl target char(length(source));\r\ndcl (to value ('ABCDEFGHIJKLMNOPQRSTUVWXYZ'),\r\nfrom value ('abcdefghijklmnopqrstuvwxyz')) char;\r\ntarget = translate(source, to, from);\r\n/* "EIN RAETSEL GIBT ES NICHT." */\r\nNote that you could also use the UPPERCASE built-in for the same purpose as the\r\nTRANSLATE built-in in the example above. However, while the UPPERCASE\r\nbuilt-in function will translate only the standard alphabetic characters,\r\nTRANSLATE can be used to translate other characters. For example, if "Raetsel"\r\nwere spelled with an a-umlaut, TRANSLATE could translate the a-umlaut to\r\nA-umlaut if those characters were added to the from and to strings, respectively.
TRIM = TRIM returns a nonvarying character string with characters trimmed from one or\r\nboth ends.$TRIM(x ),y,z$x, y, and z\r\nExpressions.\r\nEach must have a computational type and should have the attribute\r\nCHARACTER. If not, they are converted.\r\nx is the string from which the characters defined by y are trimmed from the\r\nleft, and the characters defined by z are trimmed from the right.\r\nIf z is omitted, it defaults to a CHARACTER(1) NONVARYING string\r\ncontaining one blank.\r\nIf y and z are both omitted, they both default to a CHAR(1) NONVARYING string\r\ncontaining one blank.\r\nExample\r\ndcl Source char value(" *** PL/I's got the Power! *** ");\r\ndcl Target char(length(Source)) varying;\r\nTarget = trim(Source, ' ', '* ');\r\n/* "*** PL/I's got the Power!" */
TRUNC = TRUNC returns an integer value that is the truncated value of x. If x is positive or\r\n0, this is the largest integer value less than or equal to x. If x is negative, this is the\r\nsmallest integer value greater than or equal to x.$TRUNC(x)$x Real expression.\r\nThe base, mode, scale, and precision of the result match those of x. Except when x\r\nis fixed-point with precision (p,q), the precision of the result is given by:\r\n(min(N,max(p-q+1,1)),0)\r\nwhere N is the maximum number of digits allowed.
TYPE = TYPE returns the typed structure or union located by the handle, x.$TYPE(x)$x Handle\r\nTYPE(x) dereferences the typed structure (or union) x. For an example of the TYPE\r\nbuilt-in functions, see ?TYPE pseudovariable? on page 680.\r\nTYPE pseudovariable\r\nThe TYPE pseudovariable assigns a typed structure or union to the storage located\r\nby the handle x.\r\nx Handle\r\nGiven a defined structure T, the following assignments are valid:\r\ndcl P1 handle T;\r\ndcl P2 handle T;\r\ndcl D1 type T;\r\ndcl D2 type T;\r\nD1 = type(P2); /* Assigns the storage located by P2 to D1 */\r\ntype(P1) = type(P2);\r\ntype(P1) = D2; /* Assigns D2 to the storage located by P1 */\r\nTYPE pseudovariable
ULENGTH = ULENGTH returns a FIXED BIN(31) value which is the number of UTF characters\r\nheld in a string.$ULENGTH(x)$x Expression which must have CHARACTER or WIDECHAR type.\r\nIf x has CHARACTER type, then the string must contain valid UTF-8 data. If not,\r\nthe program is in error.\r\nIf x has WIDECHAR type, then the string must contain valid UTF-16 data. If not,\r\nthe program is in error.\r\nULENGTH will return the number of UTF-8 or UTF-16 characters held in the\r\nCHAR or WIDECHAR argument, respectively. It does not return the number of\r\ncharacters if the string were normalized. So, for example, in UTF-8, a lowercase a\r\numlaut may be represented in the normalized or canonical form via the string\r\n'c3_a4'x or in the unnormalized or combining form as '61_cc_88'x, but ULENGTH\r\nwill return 1 for the string 'c3_a4'x and 2 for the string '61_cc_88'x.
ULENGTH8 = ULENGTH8 returns a FIXED BIN(31) value which is the length of a CHAR string\r\nneeded if the UTF characters held in a string were converted to UTF-8.$ULENGTH8(x)$x Expression which must have CHARACTER or WIDECHAR type.\r\nIf x has CHARACTER type, then ULENGTH8 is the same as LENGTH, and the\r\nstring will not be checked for valid UTF-8 data.\r\nIf x has WIDECHAR type, then the string must contain valid UTF-16 data, and\r\nULENGTH8 will return the length of the CHAR string that would result if x were\r\nconverted from UTF-16 to UTF-8. If the string does not contain valid UTF-16 data,\r\nthe program is in error.\r\nFor example, if x equals the WIDECHAR string '004B_00E4_0073_0065'wx, then\r\nv ULENGTH8(x) returns 5
ULENGTH16 = ULENGTH16 returns a FIXED BIN(31) value which is the length of a WIDECHAR\r\nstring needed if the UTF characters held in a string were converted to UTF-16.$ULENGTH16(x)$x Expression which must have CHARACTER or WIDECHAR type.\r\nIf x has CHAR type, then the string must contain valid UTF-8 data, and\r\nULENGTH16 will return the length of the WIDECHAR string that would result if\r\nx were converted from UTF-8 to UTF-16. If the string does not contain valid UTF-8\r\ndata, the program is in error.\r\nIf x has WIDECHAR type, then ULENGTH16 is the same as LENGTH, and the\r\nstring will not be checked for valid UTF-16 data.\r\nFor example, if x equals the CHARACTER string '4b_c3_a4_73_65'x, then\r\nv ULENGTH16(x) returns 4
UNALLOCATED = UNALLOCATED returns a bit(1) value indicating whether or not a specified\r\npointer value is the start of a piece of allocated storage. To use this built-in\r\nfunction, you must also specify the CHECK(STORAGE) compile-time option.$UNALLOCATED(P)$p Pointer expression.\r\nUNALLOCATED returns the bit(1) value '1'b if the specified pointer value is not\r\nthe start of a piece of storage that is obtained with the ALLOCATE statement or\r\nthe ALLOCATE built-in function.\r\nNote that the pointer passed to UNALLOCATED is "rounded down" to the nearest\r\ndoubleword and that rounded value is compared against all allocated addresses\r\nwhen similarly rounded down.
UNSIGNED = UNSIGNED returns an unsigned FIXED BINARY value of x, with a precision\r\nspecified by p and q.$UNSIGNED(x ),p,q$x Expression.\r\np Integer. It specifies the number of digits to be maintained throughout the\r\noperation.\r\nq Optionally-signed integer. It specifies the scaling factor of the result. For a\r\nfixed-point result, if p is given and q is omitted, a scaling factor of zero is the\r\ndefault.
UNSPEC = UNSPEC returns a bit string that is the internal coded form of x.$UNSPEC(x)$x Scalar, array, structure, or union expression.\r\nThe UNSPEC built-in function is subject to the following rules:\r\nv Under the compiler option USAGE( UNSPEC(IBM) ),\r\n? UNSPEC of structure references and expressions is not allowed.\r\n? UNSPEC of an array yields an array of BIT.\r\nv Under the compiler option USAGE( UNSPEC(ANS) ),\r\n? For aggregates, UNSPEC is allowed only for those that contain no padding\r\nbytes or bits.\r\n? The result will always be BIT scalar. UNSPEC of an array does not yield an\r\narray of BIT.\r\nNote: Use of UNSPEC can affect the portability of your program.\r\nThe length of the returned bit string depends on the attributes of x, as shown in\r\nTable 64.\r\nTable 64. Length of bit string returned by UNSPEC\r\nBit-String length Attribute of x\r\n8 SIGNED FIXED BINARY(p,q), 1 <= p <= 7\r\nUNSIGNED FIXED BINARY(p,q), 1 <= p <= 8\r\nORDINAL SIGNED PRECISION(p), 1 <= p <= 7\r\nORDINAL UNSIGNED PRECISION(p), 1 <= p <= 8\r\n16 SIGNED FIXED BINARY(p,q), 8 <= p <= 15\r\nUNSIGNED FIXED BINARY(p,q), 9 <= p <= 16\r\nORDINAL SIGNED PRECISION(p), 8 <= p <= 15\r\nORDINAL UNSIGNED PRECISION(p), 9 <= p <= 16\r\n32 ENTRY LIMITED\r\nSIGNED FIXED BINARY(p,q), 16 <= p <= 31\r\nUNSIGNED FIXED BINARY(p,q), 17 <= p <= 32\r\nORDINAL SIGNED PRECISION(p), 16 <= p <= 31\r\nORDINAL UNSIGNED PRECISION(p), 17 <= p<= 32\r\nFLOAT BINARY(p), 1 <= p <= 21\r\nFLOAT DECIMAL(p), 1 <= p <= 6 if not DFP\r\nFLOAT DECIMAL(p), 1 <= p <= 7 if DFP\r\nOFFSET\r\nFILE constant or variable\r\nPOINTER\r\nHANDLE\r\nTable 64. Length of bit string returned by UNSPEC (continued)\r\nBit-String length Attribute of x\r\n64 SIGNED FIXED BINARY(p), 31 < p\r\nUNSIGNED FIXED BINARY(p), 32 < p\r\nFLOAT BINARY(p), 21 < p < 53\r\nFLOAT DECIMAL(p), 7 <= p <= 16 if not DFP\r\nFLOAT DECIMAL(p), 8 <= p <= 16 if DFP\r\nLABEL constant or variable\r\nENTRY constant or variable\r\n128 FLOAT BINARY(p), 54 <= p\r\nFLOAT DECIMAL(p), 17 <= p\r\nTASK\r\nn BIT(n)\r\n8*n CHARACTER(n)PICTURE (with character-string-value length of n)\r\n16*n GRAPHIC(n)WIDECHAR(n)\r\n16+n BIT(n) VARYING where n is the maximum length of x\r\n16+(8*n) CHARACTER(n) VARYING where n is the maximum length of x\r\n8+(8*n) CHARACTER(n) VARYINGZ where n is the maximum length of x\r\n16+(16*n) GRAPHIC(n) VARYING where n is the maximum length of\r\nxWIDECHAR(n) VARYING where n is the maximum length of x\r\n16+(16*n) GRAPHIC(n) VARYINGZ where n is the maximum length of\r\nxWIDECHAR(n) VARYINGZ where n is the maximum length of x\r\n8*(n+16) AREA (n)\r\n8*FLOOR(n) FIXED DECIMAL (p,q) where n = (p+2)/2\r\nAlignment and storage requirements for program-control data can vary across\r\nsupported systems.\r\nIf x is a varying-length string, its two-byte prefix is included in the returned bit\r\nstring. If x is an area, the returned value includes the control information.\r\nUNSPEC pseudovariable\r\nThe UNSPEC pseudovariable assigns a bit value directly to x; that is, without\r\nconversion. The bit value is padded, if necessary, on the right with '0'B to match\r\nthe length of x, according to Table 64.\r\nx Reference.\r\nIf x is a varying length string, its 2-byte prefix is included in the field to which the\r\nbit value is assigned. If x is an area, its control information is included in the\r\nreceiving field.\r\nThe pseudovariable is subject to the rules for the UNSPEC built-in function\r\ndescribed in ?UNSPEC? on page 686.\r\nNote: Use of UNSPEC can affect the portability of your program.\r\nExample\r\ndcl 1 Str1 nonasgn static,\r\n2 * fixed bin(15) littleendian init(16), /* '1000'X */\r\n2 * char init('33'x),\r\n2 * bit init('1'b),\r\n2 Ba(4) bit init('1'b, '0'b, '1'b, '0'b),\r\n2 B3 bit(3) init('111'b),\r\n2 * char(0);\r\ndcl Bit_Str1 bit(size(Str1)*8);\r\ndcl Bit_Ba bit(dim(Ba)*length(Ba(1)));\r\ndcl Bit_B3 bit(length(B3));\r\nBit_Ba = unspec(Ba); /* result is scalar '1010'B not an array */\r\nBit_B3 = unspec(B3); /* '111'B */\r\nBit_Str1 = unspec(Str1); /* '100033D7'B4 or\r\n'100033'B4 \ '11010111'B */\r\nUNSPEC pseudovariable
UPOS = UPOS returns a FIXED BIN(31) value which is the index of the nth UTF character\r\nin a string.$UPOS(x,n)$x Expression which must have CHARACTER or WIDECHAR type.\r\nn Expression which must have computational type and which will be converted\r\nto FIXED BIN(31) if necessary.\r\nIf x has CHARACTER type, then the string must contain valid UTF-8 data. If not,\r\nthe program is in error.\r\nIf x has WIDECHAR type, then the string must contain valid UTF-16 data. If not,\r\nthe program is in error.\r\nIf n is not positive or if n is larger than ULENGTH(x), then zero will be returned.\r\nOtherwise, if x has CHARACTER type, then UPOS(x,n) will return the position of\r\nthe byte where the nth UTF-8 character starts, and if x has WIDECHAR type, then\r\nUPOS(x,n) will return the position of the widechar character where the nth UTF-16\r\ncharacter starts.\r\nFor example, if x equals the CHARACTER string '4b_c3_a4_66_65_72'x, then\r\nv UPOS(x,1) returns 1\r\nv UPOS(x,2) returns 2\r\nv UPOS(x,3) returns 4\r\nv UPOS(x,4) returns 5\r\nv UPOS(x,5) returns 6
UPPERCASE = UPPERCASE returns a character string with all the alphabetic characters from a to\r\nz converted to their uppercase equivalent.$UPPERCASE(x)$x Expression. If necessary, x is converted to character.\r\nUPPERCASE(x) is equivalent to\r\nTRANSLATE( x,\r\n'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\r\n'abcdefghijklmnopqrstuvwxyz' )
USUBSTR = USUBSTR returns a substring of a UTF string.$USUBSTR(x,i,j)$x Expression which must have CHARACTER or WIDECHAR type.\r\ni Expression which must have computational type and which will be converted\r\nto FIXED BIN(31) if necessary.\r\nj Expression which must have computational type and which will be converted\r\nto FIXED BIN(31) if necessary.\r\nIf x has CHARACTER type, then the string must contain valid UTF-8 data. If not,\r\nthe program is in error.\r\nIf x has WIDECHAR type, then the string must contain valid UTF-16 data. If not,\r\nthe program is in error.\r\nThe ERROR condition (and not the STRINGRANGE condition) will also be raised\r\nif\r\nv i is less than 1, or\r\nv j is less than zero, or\r\nv i + j - 1 is larger than ULENGTH(x)\r\nIf x has CHARACTER type, then USUBSTR(x,i,j) will return a CHARACTER string\r\ncontaining the j UTF-8 characters in x starting with the ith UTF-8 character.\r\nIf x has WIDECHAR type, then USUBSTR(x,i,j) will return a WIDECHAR string\r\ncontaining the j UTF-16 characters in x starting with the ith UTF-16 character.\r\nIn general, USUBSTR(x,i,j) will not equal SUBSTR(x,i,j).\r\nFor example, if x equals the CHARACTER string '4b_c3_a4_66_65_72'x, then\r\nv USUBSTR(x,1,2) returns '4b_c3_a4'x\r\nv USUBSTR(x,2,1) returns 'c3_a4'x\r\nv USUBSTR(x,2,2) returns 'c3_a4_66'x\r\nv USUBSTR(x,3,2) returns '66_65'x
USURROGATE = USURROGATE returns a FIXED BIN(31) value which is either the index of the first\r\nof UTF surrogate pair in a string or zero if the string contains no UTF surrogate\r\npairs.$USURROGATE(x)$x Expression which must have CHARACTER or WIDECHAR type.\r\nIf x has CHARACTER type, then the string must contain valid UTF-8 data.\r\nHowever, the validity of the data will not be checked. If the data is invalid, the\r\nERROR condition will not be raised, the program is in error, and the result\r\nreturned by this function will be unpredictable.\r\nIf x has WIDECHAR type, then the string must contain valid UTF-16 data.\r\nHowever, the validity of the data will not be checked. If the data is invalid, the\r\nERROR condition will not be raised, the program is in error, and the result\r\nreturned by this function will be unpredictable.\r\nAs an example, the musical G-clef is represented by the UTF-16 surrogate pair\r\n'D834_DD1E'wx, and hence in the following code, the value 3 will be listed:\r\ndcl w wchar(20) varying;\r\ndcl jx fixed bin;\r\nw = '0020_0020_D834_DD1E'wx\r\njx = usurrogate( w );\r\nput skip list( jx );
UVALID = UVALID returns a FIXED BIN(31) value which is zero if a string contains valid\r\nUTF data and which is the index of the first invalid element if the string does not\r\ncontain valid UTF data.$UVALID(x)$x Expression which must have CHARACTER or WIDECHAR type.\r\nIf x has CHARACTER type, then UVALID(x) will return 0 if the string contains\r\nvalid UTF-8 data, and otherwise it will return the index of the byte where the first\r\ninvalid UTF-8 data starts.\r\nIf x has WIDECHAR type, then UVALID(x) will return 0 if the string contains valid\r\nUTF-16 data, and otherwise it will return the index of the widechar where the first\r\ninvalid UTF-16 data starts.\r\nNote that UVALID will indicate if the string contains valid UTF data (according to\r\nthe rules below). It does not indicate if these bytes have actually been allocated to\r\nrepresent any particular character.\r\nFor UTF-8 data, the validity of a byte varies as follows according to its range:\r\nv '00'x - '7f'x, it is valid\r\nv '80'x - 'c1'x, it is invalid\r\nv 'c2'x - 'df'x, it is valid if followed by a second byte and if that byte is in the\r\nrange '80'x to 'bf'x\r\nv 'e0'x - 'ef'x, it is valid if followed by 2 more bytes and if\r\n? when the first byte is 'e0'x, the second and third bytes must be in the ranges\r\n'a0'x to 'bf'x and '80'x to 'bf'x, respectively.\r\n? when the first byte is in the range 'e1'x to 'ec'x, the second and third bytes\r\nmust be in the ranges '80'x to 'bf'x\r\n? when the first byte is 'ed'x, the second and third bytes must be in the ranges\r\n'80'x to '9f'x and '80'x to 'bf'x, respectively.\r\n? when the first byte is in the range 'ee'x to 'ef'x, the second and third bytes\r\nmust be in the ranges '80'x to 'bf'x\r\nv 'f0'x - 'f4'x, it is valid if followed by 3 more bytes and if\r\n? when the first byte is 'f0'x, the second, third and fourth bytes must be in the\r\nranges '90'x to 'bf', '80'x to 'bf'x and '80'x to 'bf'x, respectively.\r\n? when the first byte is in the range 'f1'x to 'f3'x, the second, third and fourth\r\nbytes must be in the range '80'x to 'bf'x\r\n? when the first byte is 'f4'x, the second, third and fourth bytes must be in the\r\nranges '80'x to '8f'x, '80'x to 'bf'x and '80'x to 'bf'x, respectively.\r\nv 'f5'x - 'ff'x, it is invalid\r\nFor UTF-16 data, the validity of a widechar varies as follows according to its\r\nrange:\r\nv '0000'wx - '007f'wx, it is valid and would be 1 byte if UTF-8\r\nv '0080'wx - '07ff'wx, it is valid and would be 2 bytes if UTF-8\r\nv '0800'wx - 'd7ff'wx, it is valid and would be 3 bytes if UTF-8\r\nv 'd800'wx - 'dbff'x, it is valid if followed by a second widechar with a value of at\r\nleast 'dc00'wx. It is a unicode surrogate pair and would be 4 bytes if UTF-8\r\nv 'dc00'wx - 'ffff'wx, it is valid and would be 3 bytes if UTF-8
UWIDTH = UWIDTH returns a FIXED BIN(31) value which is the width of the nth UTF\r\ncharacter in a string.$UWIDTH(x,n)$x Expression which must have CHARACTER or WIDECHAR type.\r\nn Expression which must have computational type and which will be converted\r\nto FIXED BIN(31) if necessary.\r\nIf x has CHARACTER type, then the string must contain valid UTF-8 data. If not,\r\nthe program is in error.\r\nIf x has WIDECHAR type, then the string must contain valid UTF-16 data. If not,\r\nthe program is in error.\r\nIf n is not positive or if n is larger than ULENGTH(x), then zero will be returned.\r\nOtherwise, if x has CHARACTER type, then UWIDTH(x,n) will return the width of\r\nthe nth UTF-8 character, and if x has WIDECHAR type, then UWIDTH(x,n) will\r\nreturn the width of the nth UTF-16 character.\r\nFor example, if x equals the CHARACTER string '4b_c3_a4_66_65_72'x, then\r\nv UWIDTH(x,1) returns 1\r\nv UWIDTH(x,2) returns 2\r\nv UWIDTH(x,3) returns 1\r\nv UWIDTH(x,4) returns 1\r\nv UWIDTH(x,5) returns 1
VALID = VALID returns a BIT(1) value that is '1'B under the following conditions:\r\nv If x is PICTURE and its contents are valid for x's picture specification\r\nv If x is FIXED DECIMAL and the data in x is valid fixed decimal data\r\nIf these conditions are not met, the result is '0'B.$VALID(x)$x Reference with either picture or fixed decimal type.
VALIDDATE = VALIDDATE returns a '1'B if the string d holds a date/time value that matches the\r\npattern p.$VALIDDATE ( d ),p,w$d A string expression representing a date.\r\nd specifies the input date as a character string representing date/time\r\naccording to the pattern p.\r\nd must have computational type and should have character type. If not, d is\r\nconverted to character.\r\np One of the supported date/time patterns.\r\nIf present, it specifies the date/time pattern of d. If p is missing, it is assumed\r\nto be the default date/time pattern of 'YYYYMMDDHHMISS999'.\r\np must have computational type and should have character type. If not, it is\r\nconverted to character.\r\nw Specifies an expression (such as 1950) that can be converted to an integer. If\r\nnegative, it specifies an offset to be subtracted from the value of the year when\r\nthe code runs. If omitted, w defaults to the value specified in the WINDOW\r\ncompile-time option.\r\nAllowable patterns are listed in Table 51 on page 396. For an explanation of Lilian\r\nformat, see ?Date/time built-in functions? on page 394.\r\nIf the pattern contains punctuation characters, VALIDDATE checks that the input\r\nstring contains matching characters. For example, for the pattern YYYY-MM-DD,\r\nVALIDDATE accepts 2008-03-14 but not 2008.03.14.\r\nExample\r\ndcl duedate char(8);\r\ndcl (b1,b2) bit(1);\r\nduedate = '19950228';\r\nb1 = validdate( duedate, 'YYYYMMDD' ); /* b1 = '1'b */\r\nduedate = '02301995';\r\nb2 = validdate( duedate, 'DDMMYYYY' ); /* b2 = '0'b */
VARGLIST = VARGLIST returns the address of the first optional parameter passed to a\r\nprocedure with a variable number of arguments$VARGLIST()$VARGLIST may be used only inside a procedure whose last parameter has the\r\nLIST attribute.
VARGSIZE = VARGSIZE returns the number of bytes that a variable would occupy on the stack\r\nif it were passed byvalue.$VARGSIZE(x)$x A variable of any data type, data organization, alignment, and storage class,\r\nexcept as listed below.\r\nx cannot be:\r\nv A BASED, DEFINED, parameter, subscripted, or structure or union\r\nbase-element variable that is an unaligned fixed-length bit string\r\nv A minor structure or union whose first or last base element is an unaligned\r\nfixed-length bit string (except where it is also the first or last element of the\r\ncontaining major structure or union)\r\nv A major structure or union that has the BASED, DEFINED, or parameter\r\nattribute, and which has an unaligned fixed-length bit string as its first or\r\nlast element\r\nv A variable not in connected storage\r\nVARGSIZE(x) returns the number of bytes that x would occupy on the stack if it\r\nwere passed byvalue. This value will be at least as large as SIZE(x); it will be\r\nlarger if the value returned by SIZE(x) needs to be rounded up to a 4-byte\r\nmultiple.\r\nVARGSIZE is meant to be used only inside a procedure whose last parameter has\r\nthe LIST attribute.
VERIFY = VERIFY returns an unscaled REAL FIXED BINARY value indicating the position in\r\nx of the leftmost character, widechar, graphic, or bit that is not in y. It also allows\r\nyou to specify the location within x at which to begin processing.\r\nIf all the characters, widechars, graphics, or bits in x do appear in y, a value of\r\nzero is returned. If x is the null string, a value of zero is returned. If x is not the\r\nnull string and y is the null string, the value of n is returned. The default value for\r\nn is one.$VERIFY(x,y ),n$x String-expression.\r\ny String-expression.\r\nn Expression n specifies the location within x where processing begins. It must\r\nhave a computational type and is converted to FIXED BINARY(31,0).\r\nUnless 1 ? n ? LENGTH(x) + 1, the STRINGRANGE condition, if enabled, is raised.\r\nIts implicit action and normal return give a result of 0. If n = LENGTH(x) + 1, the\r\nresult is zero.\r\nThe BIFPREC compiler option determines the precision of the result returned.\r\nVERIFY will perform best when the second and third arguments are either literals,\r\nnamed constants declared with the VALUE attribute, or restricted expressions.\r\nExample\r\nX = ' a b'; /* Two blanks in each space */\r\nY = ' '; /* One blank */\r\nN = 1;\r\nI = verify(X,Y,N); /* I = 3 */\r\ndo while (I > 0);\r\ndisplay ( 'Nonblank at position ' \ trim(I) );\r\nN = I + 1;\r\nI = verify(X,Y,N);\r\nend;\r\nAfter the first pass through the do-loop, N=4 and VERIFY(X,Y,N) returns 6. After\r\nthe second pass, N=7 (LENGTH(x)+1), VERIFY(X,Y,N) now returns 0, and the loop\r\nends.\r\nFor more examples of the VERIFY built-in function, see ?SEARCH? on page 640.
VERIFYR = The VERIFYR function performs the same operation as the VERIFY built-in\r\nfunction except that:\r\nv The verification is done from right to left.\r\nv The default value for n is LENGTH(x).$VERIFYR(x,y ),n$Unless 0 ? n ? LENGTH(x), the STRINGRANGE condition, if enabled, is raised. If\r\nn = 0, the result is zero.\r\nThe BIFPREC compiler option determines the precision of the result returned.\r\nFor argument descriptions, refer to ?VERIFY? on page 700.\r\nExample\r\nX = 'a b '; /* Two blanks in each space */\r\nY = ' '; /* One blank */\r\nN = length(X); /* N = 6 */\r\nI = verifyr(X,Y,N); /* I = 4 */\r\ndo while (I > 0);\r\ndisplay ( 'Nonblank at position ' \ trim(I) );\r\nN = I ? 1;\r\nI = verifyr(X,Y,N);\r\nend;\r\nAfter the first pass through the do-loop, N=3 and VERIFYR(X,Y,N) returns 1. After\r\nthe second pass, N=0, VERIFYR(X,Y,N) returns 0, and the loop ends. For another\r\nexample, see ?SEARCHR? on page 642.
WCHARVAL = WCHARVAL returns the WIDECHAR(1) value corresponding to an integer.$WCHARVAL ( n )$n Expression converted to UNSIGNED FIXED BIN(16) if necessary.\r\nIf n is in bigendian format, WCHARVAL(n) has the same bit value as n (that is,\r\nUNSPEC(WCHARVAL(n)) is equal to UNSPEC(n)), but it has the attributes\r\nWIDECHAR(1).\r\nWCHARVAL is the inverse of RANK (when applied to widechar).
WEEKDAY = WEEKDAY returns a FIXED BINARY(31,0) value that is the number of days x\r\nconverted to the day of the week, where 1=Sunday, 2=Monday, . . . 7=Saturday. If x\r\nis missing, it is assumed to be DAYS for today.$WEEKDAY( )x$x Expression. If present, x specifies the input date as days. If missing, x is\r\nassumed to be DAYS().\r\nIf x is missing and today's date is not available from the system, a result of\r\nzero is returned.\r\nx must have computational type and will be converted to FIXED\r\nBINARY(31,0), if necessary.\r\nFor an example of WEEKDAY, see ?SECS? on page 643.
WIDECHAR = WIDECHAR returns the widechar value of x, with a length specified by y.$WIDECHAR(x )y$Abbreviation: WCHAR\r\nx Expression.\r\nx must have a computational type.\r\nThe values of x are not checked.\r\ny Expression. If necessary, y is converted to a real fixed-point binary value.\r\nIf y is omitted, the length is determined by the rules for type conversion.\r\ny cannot be negative.\r\nIf y = 0, the result is the null widechar string.\r\n
WLOW = WLOW returns a widechar string of length x, where each widechar has the lowest\r\nwidechar value (hexadecimal 0000).$WLOW(x)$x Expression. If necessary, x is converted to a positive real fixed-point binary\r\nvalue. If x = 0, the result is the null widechar string.
XMLCHAR = The XMLCHAR built-in function dumps data from a structure as XML into a\r\nbuffer. It returns the number of bytes written to the buffer. If the buffer is too\r\nsmall, the structure data is truncated and the number of bytes needed for the\r\nbuffer to contain the structure is returned.$XMLCHAR ( x , p , n )$x Structure-reference.\r\nThe structure-reference x must conform to the following rules:\r\nv It must contain only computational data, that is, only string and numeric\r\ndata. However, it must not contain any GRAPHIC or WIDECHAR elements.\r\nv It may contain arrays, but if it is an array itself, it must be completely\r\nsubscripted.\r\nv It may contain substructures, but any contained substructure must not use\r\nan asterisk (*) in place of a name. However, an asterisk may be used as the\r\nname of a base element, but in that case, the unnamed element will not be\r\nwritten to the target buffer.\r\np Address of target buffer.\r\nn Length of target buffer.\r\nThe buffer length must have a computational type and will be converted to\r\nFIXED BINARY(31,0).\r\nIt must be nonnegative.\r\nWhen the XML output is created, it follows these rules:\r\nv When no variable has the XMLATTR attribute, each name in the structure is\r\nwritten out, first enclosed in "<" and ">" and later enclosed in "</" and ">".\r\nv When a variable has the XMLATTR attribute, the field is presented as an\r\nattribute of its containing structure.\r\nv When a variable has the XMLOMIT attribute, the field is omitted if it has a null\r\nvalue.\r\nv Numeric and bit data is converted to character.\r\nv Leading and trailing blanks are trimmed wherever possible.\r\nNote: By default the names of the variables in the generated XML output are all in\r\nupper case. The CASE(ASIS) suboption of the XML compiler option can be\r\nused to specify that the names appear in the case in which they were\r\ndeclared.\r\nExample of using XMLCHAR\r\nGiven this code fragment:\r\ndcl buffer char(800);\r\ndcl written fixed bin(31);\r\ndcl next pointer;\r\ndcl left fixed bin(31);\r\ndcl\r\n1 a,\r\n2 a1,\r\n3 b1 char(8),\r\n3 b2 char(8),\r\n2 a2,\r\n3 c1 fixed bin,\r\n3 c2 fixed dec(5,1);\r\nb1 = ' t1';\r\nb2 = 't2';\r\nc1 = 17;\r\nc2 = -29;\r\nnext = addr(buffer);\r\nleft = stg(buffer);\r\nwritten = xmlchar( a, next, left );\r\nnext += written;\r\nleft -= written;\r\nThe following bytes would be written to the buffer, and written would be set\r\nequal to 72.\r\n<A><A1><B1>t1</B1><B2>t2</B2></A1><A2><C1>17</C1><C2>-29.0</C2></A2></A>
Y4DATE = Y4DATE takes a date value with the patter 'YYMMDD' and returns the date value\r\nwith the two-digit year widened to a four-digit year.$Y4DATE(d ),w$d A string expression representing a date.\r\nd must have computational type and should have character type. If not, d is\r\nconverted to character.\r\nw Specifies an expression (such as 1950) that can be converted to an integer. If\r\nnegative, it specifies an offset to be subtracted from the value of the year when\r\nthe code runs. If omitted, w defaults to the value specified in the WINDOW\r\ncompile-time option.\r\nThe returned value has the attributes CHAR(8) NONVARYING and is calculated as\r\nfollows:\r\ndcl y2 pic'99';\r\ndcl y4 pic'9999';\r\ndcl cc pic'99';\r\ny2 = substr(d,1,2);\r\ncc = w/100;\r\nif y2 < mod(w,100) then\r\ny4 = 100*cc + 100 + y2;\r\nelse\r\ny4 = 100*cc + y2;\r\nreturn( y4 || substr(d,3) );\r\nY4DATE('990101',1950) returns '19990101'\r\nY4DATE('000101',1950) returns '20000101'
Y4JULIAN = Y4JULIAN takes a date value with the patter 'YYDDD' and returns the date value\r\nwith the two-digit year widened to a four-digit year.$Y4JULIAN(d ),w$d A string expression representing a date. The length of d must be at least 5. If it\r\nis larger than 5, excess characters must be formed by leading blanks.\r\nd must have computational type and should have character type. If not, it is\r\nconverted to character.\r\nw Specifies an expression (such as 1950) that can be converted to an integer. If\r\nnegative, it specifies an offset to be subtracted from the value of the year when\r\nthe code runs. If omitted, w defaults to the value specified in the WINDOW\r\ncompile-time option.\r\nThe returned value has the attributes CHAR(7) NONVARYING and is calculated as\r\nfollows:\r\ndcl y2 pic'99';\r\ndcl y4 pic'9999';\r\ndcl c pic'99';\r\ny2 = substr(d,1,2);\r\ncc = w/100;\r\nif y2 < mod(w,100) then\r\ny4 = 100*cc + 100 + y2;\r\nelse\r\ny4 = 100*cc + y2;\r\nreturn( y4 || substr(d,3) );\r\nY4JULIAN('99001',1950) returns '1999001'\r\nY4JULIAN('00001',1950) returns '2000001'.
